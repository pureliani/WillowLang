Project Path: WillowLang

Source Tree:

```txt
WillowLang
├── Cargo.lock
├── Cargo.toml
├── README.md
├── rustfmt.toml
└── src
    ├── _to_be_removed_(ast_checkers)
    │   ├── expressions
    │   │   ├── check_access_expr.rs
    │   │   ├── check_and_expr.rs
    │   │   ├── check_arithmetic_negation_expr.rs
    │   │   ├── check_array_literal_expr.rs
    │   │   ├── check_codeblock_expr.rs
    │   │   ├── check_equality_expr.rs
    │   │   ├── check_fn_call_expr.rs
    │   │   ├── check_fn_expr.rs
    │   │   ├── check_generic_apply_expr.rs
    │   │   ├── check_identifier_expr.rs
    │   │   ├── check_if_expr.rs
    │   │   ├── check_inequality_expr.rs
    │   │   ├── check_logical_negation_expr.rs
    │   │   ├── check_numeric_expr.rs
    │   │   ├── check_or_expr.rs
    │   │   ├── check_static_access_expr.rs
    │   │   ├── check_struct_init_expr.rs
    │   │   ├── check_type_cast_expr.rs
    │   │   └── mod.rs
    │   └── statements
    │       └── mod.rs
    ├── ast
    │   ├── decl.rs
    │   ├── expr.rs
    │   ├── mod.rs
    │   ├── stmt.rs
    │   └── type_annotation.rs
    ├── codegen
    │   └── mod.rs
    ├── compile
    │   ├── mod.rs
    │   └── string_interner.rs
    ├── hir
    │   ├── cfg.rs
    │   ├── errors.rs
    │   ├── expressions
    │   │   ├── access.rs
    │   │   ├── and.rs
    │   │   ├── binary_op.rs
    │   │   ├── bool_literal.rs
    │   │   ├── codeblock.rs
    │   │   ├── fn.rs
    │   │   ├── fn_call.rs
    │   │   ├── identifier.rs
    │   │   ├── if.rs
    │   │   ├── list_literal.rs
    │   │   ├── match.rs
    │   │   ├── mod.rs
    │   │   ├── number_literal.rs
    │   │   ├── or.rs
    │   │   ├── static_access.rs
    │   │   ├── string.rs
    │   │   ├── struct_init.rs
    │   │   ├── typecast.rs
    │   │   └── unary_op.rs
    │   ├── mod.rs
    │   ├── statements
    │   │   ├── assignment.rs
    │   │   ├── enum_decl.rs
    │   │   ├── expression.rs
    │   │   ├── from.rs
    │   │   ├── mod.rs
    │   │   ├── return.rs
    │   │   ├── type_alias_decl.rs
    │   │   ├── var_decl.rs
    │   │   └── while.rs
    │   ├── types
    │   │   ├── checked_declaration.rs
    │   │   ├── checked_type.rs
    │   │   └── mod.rs
    │   └── utils
    │       ├── check_binary_numeric_op.rs
    │       ├── check_is_assignable.rs
    │       ├── check_is_casting_allowed.rs
    │       ├── check_is_equatable.rs
    │       ├── check_type.rs
    │       ├── get_numeric_type_rank.rs
    │       ├── instruction_emitters.rs
    │       ├── is_float.rs
    │       ├── is_integer.rs
    │       ├── is_signed.rs
    │       ├── mod.rs
    │       ├── new_basic_block.rs
    │       ├── scope.rs
    │       ├── set_basic_block_terminator.rs
    │       ├── type_to_string.rs
    │       └── use_basic_block.rs
    ├── lib.rs
    ├── main.rs
    ├── parse
    │   ├── expressions
    │   │   ├── mod.rs
    │   │   ├── parse_codeblock_expr.rs
    │   │   ├── parse_enum_init_expr.rs
    │   │   ├── parse_fn_call_expr.rs
    │   │   ├── parse_fn_expr.rs
    │   │   ├── parse_if_expr.rs
    │   │   ├── parse_list_literal_expr.rs
    │   │   ├── parse_match_expr.rs
    │   │   ├── parse_parenthesized_expr.rs
    │   │   └── parse_struct_init_expr.rs
    │   ├── mod.rs
    │   ├── statements
    │   │   ├── mod.rs
    │   │   ├── parse_assignment_stmt.rs
    │   │   ├── parse_break_stmt.rs
    │   │   ├── parse_continue_stmt.rs
    │   │   ├── parse_enum_decl.rs
    │   │   ├── parse_expr_stmt.rs
    │   │   ├── parse_from_stmt.rs
    │   │   ├── parse_return_stmt.rs
    │   │   ├── parse_struct_decl.rs
    │   │   ├── parse_type_alias_decl.rs
    │   │   ├── parse_var_decl.rs
    │   │   └── parse_while_stmt.rs
    │   └── type_annotations
    │       ├── mod.rs
    │       ├── parse_fn_type_annotation.rs
    │       └── parse_parenthesized_type_annotation.rs
    └── tokenize
        ├── mod.rs
        ├── tokenize_documentation.rs
        ├── tokenize_identifier.rs
        ├── tokenize_number.rs
        ├── tokenize_punctuation.rs
        └── tokenize_string.rs

```

`WillowLang/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "codespan-reporting"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe6d2e5af09e8c8ad56c969f2157a3d4238cebc7c55f0a517728c38f7b200f81"
dependencies = [
 "serde",
 "termcolor",
 "unicode-width",
]

[[package]]
name = "diff"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8"

[[package]]
name = "pretty_assertions"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ae130e2f271fbc2ac3a40fb1d07180839cdbbe443c7a27e1e3c13c5cac0116d"
dependencies = [
 "diff",
 "yansi",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "syn"
version = "2.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ce2b7fc941b3a24138a0a7cf8e858bfc6a992e7978a068a5c760deb0ed43caf"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "willow"
version = "0.1.0"
dependencies = [
 "codespan-reporting",
 "pretty_assertions",
 "unicode-segmentation",
]

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "yansi"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"

```

`WillowLang/Cargo.toml`:

```toml
[package]
name = "willow"
version = "0.1.0"
edition = "2021"

[dependencies]
codespan-reporting = "0.12.0"
pretty_assertions = "1.4.1"
unicode-segmentation = "1.12.0"

```

`WillowLang/rustfmt.toml`:

```toml
max_width = 130

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_access_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        IdentifierNode, Span,
    },
    check::{SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_access_expr(&mut self, left: Box<Expr>, field: IdentifierNode, span: Span) -> CheckedExpr {
        let checked_left = self.check_expr(*left);

        let expr_type = match &checked_left.ty.kind {
            TypeKind::Struct(fields) => fields
                .iter()
                .find(|p| p.identifier == field)
                .map(|p| p.constraint.clone())
                .unwrap_or_else(|| {
                    self.errors.push(SemanticError::AccessToUndefinedField { field });

                    Type {
                        kind: TypeKind::Unknown,
                        span,
                    }
                }),
            _ => {
                self.errors.push(SemanticError::CannotAccess {
                    target: checked_left.ty.clone(),
                });

                Type {
                    kind: TypeKind::Unknown,
                    span,
                }
            }
        };

        CheckedExpr {
            ty: expr_type,
            kind: CheckedExprKind::Access {
                left: Box::new(checked_left.clone()),
                field,
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_and_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_and_expr(&mut self, left: Box<Expr>, right: Box<Expr>, span: Span) -> CheckedExpr {
        let mut expr_type = Type {
            kind: TypeKind::Bool,
            span,
        };

        let checked_left = self.check_expr(*left);
        let checked_right = self.check_expr(*right);

        let expected_left = Type {
            kind: TypeKind::Bool,
            span: checked_left.ty.span,
        };

        if !self.check_is_assignable(&checked_left.ty, &expected_left) {
            self.errors.push(SemanticError::TypeMismatch {
                expected: expected_left,
                received: checked_left.ty.clone(),
            });

            expr_type.kind = TypeKind::Unknown;
        }

        let expected_right = Type {
            kind: TypeKind::Bool,
            span: checked_right.ty.span,
        };

        if !self.check_is_assignable(&checked_right.ty, &expected_right) {
            self.errors.push(SemanticError::TypeMismatch {
                expected: expected_right,
                received: checked_right.ty.clone(),
            });

            expr_type.kind = TypeKind::Unknown;
        }

        CheckedExpr {
            kind: CheckedExprKind::And {
                left: Box::new(checked_left),
                right: Box::new(checked_right),
            },
            ty: expr_type,
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_arithmetic_negation_expr.rs`:

```rs
use std::collections::HashSet;

use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::is_signed::is_signed, SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_arithmetic_negation_expr(&mut self, right: Box<Expr>, span: Span) -> CheckedExpr {
        let checked_right = self.check_expr(*right);

        let expr_type = match &checked_right.ty.kind {
            t if is_signed(&t) => Type { kind: t.clone(), span },
            _ => {
                let expected = HashSet::from([
                    Type {
                        kind: TypeKind::I8,
                        span: checked_right.ty.span,
                    },
                    Type {
                        kind: TypeKind::I16,
                        span: checked_right.ty.span,
                    },
                    Type {
                        kind: TypeKind::I32,
                        span: checked_right.ty.span,
                    },
                    Type {
                        kind: TypeKind::I64,
                        span: checked_right.ty.span,
                    },
                    Type {
                        kind: TypeKind::ISize,
                        span: checked_right.ty.span,
                    },
                    Type {
                        kind: TypeKind::F32,
                        span: checked_right.ty.span,
                    },
                    Type {
                        kind: TypeKind::F64,
                        span: checked_right.ty.span,
                    },
                ]);

                self.errors.push(SemanticError::TypeMismatch {
                    expected: Type {
                        kind: TypeKind::Union(expected),
                        span: checked_right.ty.span,
                    },
                    received: checked_right.ty.clone(),
                });

                Type {
                    kind: TypeKind::Unknown,
                    span,
                }
            }
        };

        CheckedExpr {
            ty: expr_type,
            kind: CheckedExprKind::Neg {
                right: Box::new(checked_right),
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_array_literal_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::union_of::union_of, SemanticChecker},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_array_literal_expr(&mut self, items: Vec<Expr>, span: Span) -> CheckedExpr {
        let size = items.len();

        let checked_items: Vec<CheckedExpr> = items.into_iter().map(|item| self.check_expr(item)).collect();

        let unionized_types = union_of(checked_items.iter().map(|item| item.ty.clone()), span);

        let expr_type = Type {
            kind: TypeKind::Array {
                item_type: Box::new(unionized_types),
                size,
            },
            span,
        };

        CheckedExpr {
            ty: expr_type,
            kind: CheckedExprKind::ArrayLiteral { items: checked_items },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_codeblock_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::BlockContents,
        checked::{
            checked_expression::CheckedBlockContents,
            checked_type::{Type, TypeKind},
        },
    },
    check::{utils::scope::ScopeKind, SemanticChecker},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_codeblock(&mut self, block_contents: BlockContents) -> (Type, CheckedBlockContents) {
        self.enter_scope(ScopeKind::CodeBlock);
        let checked_codeblock_statements = self.check_stmts(block_contents.statements);
        let checked_codeblock_final_expr = block_contents.final_expr.map(|fe| {
            let checked_final_expr = self.check_expr(*fe);

            Box::new(checked_final_expr)
        });
        self.exit_scope();

        let ty = checked_codeblock_final_expr.clone().map(|fe| fe.ty).unwrap_or(Type {
            kind: TypeKind::Void,
            span: block_contents.span,
        });

        (
            ty,
            CheckedBlockContents {
                final_expr: checked_codeblock_final_expr,
                statements: checked_codeblock_statements,
            },
        )
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_equality_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::check_is_equatable::check_is_equatable, SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_equality_expr(&mut self, left: Box<Expr>, right: Box<Expr>, span: Span) -> CheckedExpr {
        let mut type_kind = TypeKind::Bool;

        let checked_left = self.check_expr(*left);
        let checked_right = self.check_expr(*right);

        if !check_is_equatable(&checked_left.ty.kind, &checked_right.ty.kind) {
            self.errors.push(SemanticError::CannotCompareType {
                of: checked_left.ty.clone(),
                to: checked_right.ty.clone(),
            });

            type_kind = TypeKind::Unknown
        }

        CheckedExpr {
            ty: Type { kind: type_kind, span },
            kind: CheckedExprKind::Equal {
                left: Box::new(checked_left),
                right: Box::new(checked_right),
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_fn_call_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_declaration::{CheckedFnType, CheckedParam},
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::substitute_generics::GenericSubstitutionMap, SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_fn_call_expr(&mut self, left: Box<Expr>, args: Vec<Expr>, span: Span) -> CheckedExpr {
        let checked_left = self.check_expr(*left);
        let checked_args: Vec<_> = args.into_iter().map(|arg| self.check_expr(arg)).collect();

        let return_type = match &checked_left.ty.kind {
            TypeKind::FnType(CheckedFnType {
                params,
                return_type,
                generic_params: _,
                ..
            }) => {
                if checked_args.len() != params.len() {
                    self.errors.push(SemanticError::FnArgumentCountMismatch {
                        expected: params.len(),
                        received: checked_args.len(),
                        span: checked_left.ty.span,
                    });

                    Type {
                        kind: TypeKind::Unknown,
                        span,
                    }
                } else {
                    let mut substitutions = GenericSubstitutionMap::new();
                    for (fn_param, call_arg_expr) in params.iter().zip(checked_args.iter()) {
                        self.infer_generics(&fn_param.constraint, &call_arg_expr.ty, &mut substitutions);
                    }

                    let substituted_fn_params: Vec<CheckedParam> = params
                        .iter()
                        .map(|p| CheckedParam {
                            id: p.id,
                            identifier: p.identifier,
                            constraint: self.substitute_generics(&p.constraint, &substitutions),
                        })
                        .collect();

                    let mut substituted_return = self.substitute_generics(&return_type, &substitutions);
                    substituted_return.span = span;

                    for (call_arg_expr, substituted_param) in checked_args.iter().zip(substituted_fn_params.iter()) {
                        if !self.check_is_assignable(&call_arg_expr.ty, &substituted_param.constraint) {
                            self.errors.push(SemanticError::TypeMismatch {
                                expected: substituted_param.constraint.clone(),
                                received: call_arg_expr.ty.clone(),
                            });

                            substituted_return.kind = TypeKind::Unknown;
                        }
                    }

                    substituted_return
                }
            }
            _ => {
                self.errors.push(SemanticError::CannotCall {
                    target: checked_left.ty.clone(),
                });

                Type {
                    kind: TypeKind::Unknown,
                    span,
                }
            }
        };

        CheckedExpr {
            ty: return_type,
            kind: CheckedExprKind::FnCall {
                left: Box::new(checked_left),
                args: checked_args,
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_fn_expr.rs`:

```rs
use std::{cell::RefCell, rc::Rc, vec};

use crate::{
    ast::{
        base::{
            base_declaration::{GenericParam, Param},
            base_expression::BlockContents,
            base_type::TypeAnnotation,
        },
        checked::{
            checked_declaration::{CheckedFnType, CheckedParam, CheckedVarDecl},
            checked_expression::{CheckedBlockContents, CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{
        utils::{
            scope::{ScopeKind, SymbolEntry},
            union_of::union_of,
        },
        SemanticChecker, SemanticError,
    },
};

impl<'a> SemanticChecker<'a> {
    pub fn check_fn_expr(
        &mut self,
        params: Vec<Param>,
        body: BlockContents,
        return_type: Option<TypeAnnotation>,
        generic_params: Vec<GenericParam>,
        span: Span,
    ) -> CheckedExpr {
        let fn_definition_id = self.get_definition_id();
        self.enter_scope(ScopeKind::Function);

        let checked_generic_params = self.check_generic_params(&generic_params);

        let checked_params: Vec<CheckedParam> = params
            .iter()
            .map(|param| {
                let id = self.get_definition_id();
                let checked_constraint = self.check_type_annotation(&param.constraint);

                self.scope_insert(
                    param.identifier,
                    SymbolEntry::VarDecl(Rc::new(RefCell::new(CheckedVarDecl {
                        id,
                        documentation: None,
                        identifier: param.identifier,
                        constraint: checked_constraint.clone(),
                        value: None,
                    }))),
                );

                CheckedParam {
                    id,
                    constraint: checked_constraint,
                    identifier: param.identifier,
                }
            })
            .collect();

        let checked_statements = self.check_stmts(body.statements);
        let checked_final_expr = body.final_expr.map(|fe| Box::new(self.check_expr(*fe)));

        let checked_body = CheckedBlockContents {
            statements: checked_statements.clone(),
            final_expr: checked_final_expr.clone(),
        };

        let mut return_exprs = self.check_returns(&checked_statements);
        if let Some(final_expr) = checked_final_expr {
            return_exprs.push(*final_expr);
        }

        let actual_return_type = if return_exprs.len() > 1 {
            union_of(return_exprs.iter().map(|e| e.ty.clone()), span)
        } else if return_exprs.len() == 1 {
            return_exprs.get(0).map(|e| e.ty.clone()).unwrap()
        } else {
            Type {
                kind: TypeKind::Void,
                span,
            }
        };

        let expected_return_type = return_type.map(|return_t| self.check_type_annotation(&return_t));

        let final_return_type = if let Some(explicit_return_type) = expected_return_type {
            if !self.check_is_assignable(&actual_return_type, &explicit_return_type) {
                self.errors.push(SemanticError::ReturnTypeMismatch {
                    expected: explicit_return_type.clone(),
                    received: actual_return_type.clone(),
                });
            }
            explicit_return_type
        } else {
            actual_return_type
        };

        let expr_type = Type {
            kind: TypeKind::FnType(CheckedFnType {
                params: checked_params.clone(),
                return_type: Box::new(final_return_type.clone()),
                generic_params: checked_generic_params.clone(),
                applied_type_args: vec![],
                span,
            }),
            span,
        };
        self.exit_scope();

        CheckedExpr {
            ty: expr_type,
            kind: CheckedExprKind::Fn {
                id: fn_definition_id,
                params: checked_params,
                body: checked_body,
                return_type: final_return_type,
                generic_params: checked_generic_params,
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_generic_apply_expr.rs`:

```rs
use crate::{
    ast::{
        base::{base_expression::Expr, base_type::TypeAnnotation},
        checked::{
            checked_declaration::{CheckedFnType, CheckedGenericParam},
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::substitute_generics::GenericSubstitutionMap, SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_generic_apply_expr(&mut self, left: Box<Expr>, args: Vec<TypeAnnotation>, span: Span) -> CheckedExpr {
        let checked_left = self.check_expr(*left);
        let type_args: Vec<_> = args
            .into_iter()
            .map(|type_arg| self.check_type_annotation(&type_arg))
            .collect();

        let mut substitute = |generic_params: &[CheckedGenericParam], type_args: Vec<Type>| {
            if generic_params.len() != type_args.len() {
                self.errors.push(SemanticError::GenericArgumentCountMismatch {
                    expected: generic_params.len(),
                    received: type_args.len(),
                    span,
                });

                (
                    Type {
                        kind: TypeKind::Unknown,
                        span,
                    },
                    GenericSubstitutionMap::new(),
                )
            } else {
                let mut substitutions = GenericSubstitutionMap::new();
                for (gp_decl, type_arg) in generic_params.iter().zip(type_args.into_iter()) {
                    substitutions.insert(gp_decl.identifier.name, type_arg);
                }

                let substituted = self.substitute_generics(&checked_left.ty, &substitutions);

                (substituted, substitutions)
            }
        };

        let (type_kind, substitutions) = match &checked_left.ty.kind {
            TypeKind::FnType(CheckedFnType { generic_params, .. }) => substitute(generic_params, type_args),
            _ => {
                self.errors.push(SemanticError::CannotApplyTypeArguments {
                    to: checked_left.ty.clone(),
                });

                (
                    Type {
                        kind: TypeKind::Unknown,
                        span: checked_left.ty.span,
                    },
                    GenericSubstitutionMap::new(),
                )
            }
        };

        CheckedExpr {
            ty: type_kind,
            kind: CheckedExprKind::TypeSpecialization {
                target: Box::new(checked_left),
                substitutions,
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_identifier_expr.rs`:

```rs
use crate::{
    ast::{
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        IdentifierNode, Span,
    },
    check::{utils::scope::SymbolEntry, SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_identifier_expr(&mut self, id: IdentifierNode, span: Span) -> CheckedExpr {
        let entry = self.scope_lookup(id.name);

        let kind = match entry {
            Some(e) => match e {
                SymbolEntry::TypeAliasDecl(decl) => TypeKind::TypeAliasDecl(decl.clone()),
                SymbolEntry::VarDecl(decl) => {
                    todo!()
                }
                SymbolEntry::GenericParam(_) => {
                    self.errors.push(SemanticError::CannotUseGenericParameterAsValue { span });

                    TypeKind::Unknown
                }
            },
            None => {
                self.errors.push(SemanticError::UndeclaredIdentifier { id });

                TypeKind::Unknown
            }
        };

        CheckedExpr {
            ty: Type { kind, span },
            kind: CheckedExprKind::Identifier(id),
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_if_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::{BlockContents, Expr},
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::union_of::union_of, SemanticChecker},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_if_expr(
        &mut self,
        condition: Box<Expr>,
        then_branch: BlockContents,
        else_if_branches: Vec<(Box<Expr>, BlockContents)>,
        else_branch: Option<BlockContents>,
        span: Span,
    ) -> CheckedExpr {
        todo!()
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_inequality_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{utils::check_is_equatable::check_is_equatable, SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_inequality_expr(&mut self, left: Box<Expr>, right: Box<Expr>, span: Span) -> CheckedExpr {
        let mut expr_type = Type {
            kind: TypeKind::Bool,
            span,
        };

        let checked_left = self.check_expr(*left);
        let checked_right = self.check_expr(*right);

        if !check_is_equatable(&checked_left.ty.kind, &checked_right.ty.kind) {
            self.errors.push(SemanticError::CannotCompareType {
                of: checked_left.ty.clone(),
                to: checked_right.ty.clone(),
            });

            expr_type.kind = TypeKind::Unknown;
        }

        CheckedExpr {
            ty: expr_type,
            kind: CheckedExprKind::NotEqual {
                left: Box::new(checked_left),
                right: Box::new(checked_right),
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_logical_negation_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_logical_negation_expr(&mut self, right: Box<Expr>, span: Span) -> CheckedExpr {
        let checked_right = self.check_expr(*right);

        let expected_right = Type {
            kind: TypeKind::Bool,
            span: checked_right.ty.span,
        };

        let mut expr_type = Type {
            kind: TypeKind::Bool,
            span,
        };

        if !self.check_is_assignable(&checked_right.ty, &expected_right) {
            self.errors.push(SemanticError::TypeMismatch {
                expected: expected_right,
                received: checked_right.ty.clone(),
            });

            expr_type.kind = TypeKind::Unknown
        }

        CheckedExpr {
            ty: expr_type,
            kind: CheckedExprKind::Not {
                right: Box::new(checked_right),
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_numeric_expr.rs`:

```rs
use crate::{
    ast::{
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::SemanticChecker,
    tokenize::NumberKind,
};

impl<'a> SemanticChecker<'a> {
    pub fn check_numeric_expr(&mut self, value: NumberKind, span: Span) -> CheckedExpr {
        let ty = match value {
            NumberKind::I64(_) => TypeKind::I64,
            NumberKind::I32(_) => TypeKind::I32,
            NumberKind::I16(_) => TypeKind::I16,
            NumberKind::I8(_) => TypeKind::I8,
            NumberKind::F32(_) => TypeKind::F32,
            NumberKind::F64(_) => TypeKind::F64,
            NumberKind::U64(_) => TypeKind::U64,
            NumberKind::U32(_) => TypeKind::U32,
            NumberKind::U16(_) => TypeKind::U16,
            NumberKind::U8(_) => TypeKind::U8,
            NumberKind::USize(_) => TypeKind::USize,
            NumberKind::ISize(_) => TypeKind::ISize,
        };

        CheckedExpr {
            ty: Type { kind: ty, span },
            kind: CheckedExprKind::Number { value },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_or_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
        Span,
    },
    check::{SemanticChecker, SemanticError},
};

impl<'a> SemanticChecker<'a> {
    pub fn check_or_expr(&mut self, left: Box<Expr>, right: Box<Expr>, span: Span) -> CheckedExpr {
        let mut ty = Type {
            kind: TypeKind::Bool,
            span,
        };

        let checked_left = self.check_expr(*left);
        let checked_right = self.check_expr(*right);

        let expected_left = Type {
            kind: TypeKind::Bool,
            span: checked_left.ty.span,
        };

        let expected_right = Type {
            kind: TypeKind::Bool,
            span: checked_right.ty.span,
        };

        if !self.check_is_assignable(&checked_left.ty, &expected_left) {
            self.errors.push(SemanticError::TypeMismatch {
                expected: expected_left,
                received: checked_left.ty.clone(),
            });

            ty.kind = TypeKind::Unknown;
        }

        if !self.check_is_assignable(&checked_right.ty, &expected_right) {
            self.errors.push(SemanticError::TypeMismatch {
                expected: expected_right,
                received: checked_right.ty.clone(),
            });

            ty.kind = TypeKind::Unknown;
        }

        CheckedExpr {
            ty,
            kind: CheckedExprKind::Or {
                left: Box::new(checked_left),
                right: Box::new(checked_right),
            },
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_static_access_expr.rs`:

```rs
use crate::{
    ast::{base::base_expression::Expr, checked::checked_expression::CheckedExpr, IdentifierNode, Span},
    check::SemanticChecker,
};

impl<'a> SemanticChecker<'a> {
    pub fn check_static_access_expr(&mut self, left: Box<Expr>, field: IdentifierNode, span: Span) -> CheckedExpr {
        todo!()
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_struct_init_expr.rs`:

```rs
use crate::{
    ast::{
        base::base_expression::Expr,
        checked::{
            checked_expression::CheckedExpr,
            checked_type::{Type, TypeKind},
        },
        IdentifierNode, Span,
    },
    check::SemanticChecker,
};

impl<'a> SemanticChecker<'a> {
    pub fn check_struct_literal_expr(&mut self, fields: Vec<(IdentifierNode, Expr)>, span: Span) -> CheckedExpr {
        let checked_args: Vec<(IdentifierNode, CheckedExpr)> = fields
            .into_iter()
            .map(|(ident, expr)| (ident, self.check_expr(expr)))
            .collect();

        let mut result_struct_type = Type {
            kind: TypeKind::Unknown,
            span,
        };

        todo!()
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/check_type_cast_expr.rs`:

```rs
use crate::{
    ast::{
        base::{base_expression::Expr, base_type::TypeAnnotation},
        checked::checked_expression::CheckedExpr,
        Span,
    },
    check::SemanticChecker,
};

impl<'a> SemanticChecker<'a> {
    pub fn check_type_cast_expr(&mut self, left: Box<Expr>, target: TypeAnnotation, span: Span) -> CheckedExpr {
        todo!()
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/expressions/mod.rs`:

```rs
pub mod check_access_expr;
pub mod check_and_expr;
pub mod check_arithmetic_negation_expr;
pub mod check_array_literal_expr;
pub mod check_binary_numeric_op;
pub mod check_codeblock_expr;
pub mod check_equality_expr;
pub mod check_fn_call_expr;
pub mod check_fn_expr;
pub mod check_generic_apply_expr;
pub mod check_identifier_expr;
pub mod check_if_expr;
pub mod check_inequality_expr;
pub mod check_logical_negation_expr;
pub mod check_numeric_expr;
pub mod check_or_expr;
pub mod check_static_access_expr;
pub mod check_struct_init_expr;
pub mod check_type_cast_expr;

use crate::{
    ast::{
        base::base_expression::{Expr, ExprKind},
        checked::{
            checked_expression::{CheckedExpr, CheckedExprKind},
            checked_type::{Type, TypeKind},
        },
    },
    check::SemanticChecker,
};

impl<'a> SemanticChecker<'a> {
    pub fn check_expr(&mut self, expr: Expr) -> CheckedExpr {
        match expr.kind {
            ExprKind::Not { right } => self.check_logical_negation_expr(right, expr.span),
            ExprKind::Neg { right } => self.check_arithmetic_negation_expr(right, expr.span),
            ExprKind::Add { left, right } => {
                self.check_arithmetic_operation(left, right, expr.span, |left, right| CheckedExprKind::Add { left, right })
            }
            ExprKind::Subtract { left, right } => self.check_arithmetic_operation(left, right, expr.span, |left, right| {
                CheckedExprKind::Subtract { left, right }
            }),
            ExprKind::Multiply { left, right } => self.check_arithmetic_operation(left, right, expr.span, |left, right| {
                CheckedExprKind::Multiply { left, right }
            }),
            ExprKind::Divide { left, right } => {
                self.check_arithmetic_operation(left, right, expr.span, |left, right| CheckedExprKind::Divide { left, right })
            }
            ExprKind::Modulo { left, right } => {
                self.check_arithmetic_operation(left, right, expr.span, |left, right| CheckedExprKind::Modulo { left, right })
            }
            ExprKind::LessThan { left, right } => self.check_numeric_comparison(left, right, expr.span, |left, right| {
                CheckedExprKind::LessThan { left, right }
            }),
            ExprKind::LessThanOrEqual { left, right } => self.check_numeric_comparison(left, right, expr.span, |left, right| {
                CheckedExprKind::LessThanOrEqual { left, right }
            }),
            ExprKind::GreaterThan { left, right } => self.check_numeric_comparison(left, right, expr.span, |left, right| {
                CheckedExprKind::GreaterThan { left, right }
            }),
            ExprKind::GreaterThanOrEqual { left, right } => {
                self.check_numeric_comparison(left, right, expr.span, |left, right| CheckedExprKind::GreaterThanOrEqual {
                    left,
                    right,
                })
            }
            ExprKind::Equal { left, right } => self.check_equality_expr(left, right, expr.span),
            ExprKind::NotEqual { left, right } => self.check_inequality_expr(left, right, expr.span),
            ExprKind::And { left, right } => self.check_and_expr(left, right, expr.span),
            ExprKind::Or { left, right } => self.check_or_expr(left, right, expr.span),
            ExprKind::Access { left, field } => self.check_access_expr(left, field, expr.span),
            ExprKind::StaticAccess { left, field } => self.check_static_access_expr(left, field, expr.span),
            ExprKind::TypeCast { left, target } => self.check_type_cast_expr(left, target, expr.span),
            ExprKind::GenericApply { left, args } => self.check_generic_apply_expr(left, args, expr.span),
            ExprKind::FnCall { left, args } => self.check_fn_call_expr(left, args, expr.span),
            ExprKind::StructLiteral(fields) => self.check_struct_literal_expr(fields, expr.span),
            ExprKind::BoolLiteral { value } => CheckedExpr {
                kind: CheckedExprKind::BoolLiteral { value },
                ty: Type {
                    kind: TypeKind::Bool,
                    span: expr.span,
                },
            },
            ExprKind::String(string_node) => CheckedExpr {
                kind: CheckedExprKind::String(string_node),
                ty: Type {
                    span: expr.span,
                    kind: TypeKind::Array {
                        item_type: Box::new(Type {
                            kind: TypeKind::Char,
                            span: expr.span, // TODO: come up with better span
                        }),
                        size: string_node.len,
                    },
                },
            },
            ExprKind::Number { value } => self.check_numeric_expr(value, expr.span),
            ExprKind::Identifier(id) => self.check_identifier_expr(id, expr.span),
            ExprKind::Fn {
                params,
                body,
                return_type,
                generic_params,
            } => self.check_fn_expr(params, body, return_type, generic_params, expr.span),
            ExprKind::If {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => self.check_if_expr(condition, then_branch, else_if_branches, else_branch, expr.span),
            ExprKind::ArrayLiteral { items } => self.check_array_literal_expr(items, expr.span),
            ExprKind::Block(codeblock) => {
                let (ty, checked_codeblock) = self.check_codeblock(codeblock);
                CheckedExpr {
                    ty,
                    kind: CheckedExprKind::Block(checked_codeblock),
                }
            }
        }
    }
}

```

`WillowLang/src/_to_be_removed_(ast_checkers)/statements/mod.rs`:

```rs
use std::{cell::RefCell, rc::Rc};

use crate::{
    ast::{
        base::{
            base_declaration::{TypeAliasDecl, VarDecl},
            base_expression::{Expr, ExprKind},
            base_statement::{Stmt, StmtKind},
        },
        checked::{
            checked_declaration::{CheckedTypeAliasDecl, CheckedVarDecl},
            checked_expression::{CheckedBlockContents, CheckedExprKind},
            checked_statement::CheckedStmt,
            checked_type::{Type, TypeKind},
        },
    },
    check::{
        utils::scope::{ScopeKind, SymbolEntry},
        SemanticChecker, SemanticError,
    },
};

impl<'a> SemanticChecker<'a> {
    pub fn check_stmts(&mut self, statements: Vec<Stmt>) -> Vec<CheckedStmt> {
        self.placeholder_declarations(&statements);
        statements
            .into_iter()
            .map(|s| {
                let checked = self.check_stmt(s);
                checked
            })
            .collect()
    }

    pub fn check_stmt(&mut self, stmt: Stmt) -> CheckedStmt {
        match stmt.kind {
            StmtKind::Expression(expr) => CheckedStmt::Expression(self.check_expr(expr)),
            StmtKind::VarDecl(VarDecl {
                identifier,
                constraint,
                value,
                documentation,
            }) => {
                let is_fn = matches!(
                    value,
                    Some(Expr {
                        kind: ExprKind::Fn { .. },
                        ..
                    })
                );

                let constraint = constraint.map(|c| {
                    let checked_constraint = self.check_type_annotation(&c);
                    if is_fn {
                        let placeholder = match self.scope_lookup(identifier.name) {
                            Some(SymbolEntry::VarDecl(d)) => d,
                            _ => panic!("Expected function declaration placeholder for"),
                        };
                        placeholder.borrow_mut().constraint = checked_constraint.clone();
                    };

                    checked_constraint
                });

                let checked_value = value.map(|v| self.check_expr(v));

                let final_constraint = match (&checked_value, constraint) {
                    (Some(value), Some(constraint)) => {
                        let is_assignable = self.check_is_assignable(&value.ty, &constraint);

                        if !is_assignable {
                            self.errors.push(SemanticError::TypeMismatch {
                                expected: constraint.clone(),
                                received: value.ty.clone(),
                            });
                        }

                        constraint
                    }
                    (Some(value), None) => value.ty.clone(),

                    (None, _) => {
                        self.errors.push(SemanticError::VarDeclWithoutInitializer { span: stmt.span });

                        Type {
                            kind: TypeKind::Unknown,
                            span: identifier.span,
                        }
                    }
                };

                let decl = if is_fn {
                    match self.scope_lookup(identifier.name) {
                        Some(SymbolEntry::VarDecl(decl)) => {
                            let mut mut_decl = decl.borrow_mut();
                            mut_decl.value = checked_value;
                            mut_decl.constraint = final_constraint;
                            decl.clone()
                        }
                        _ => {
                            panic!("Expected function declaration placeholder")
                        }
                    }
                } else {
                    let definition_id = self.get_definition_id();
                    let decl = Rc::new(RefCell::new(CheckedVarDecl {
                        id: definition_id,
                        identifier,
                        documentation,
                        value: checked_value,
                        constraint: final_constraint,
                    }));

                    self.scope_insert(identifier, SymbolEntry::VarDecl(decl.clone()));

                    decl
                };

                CheckedStmt::VarDecl(decl)
            }
            StmtKind::TypeAliasDecl(TypeAliasDecl {
                identifier,
                generic_params,
                value,
                documentation: _,
            }) => {
                if !self.is_file_scope() {
                    self.errors
                        .push(SemanticError::TypeAliasMustBeDeclaredAtTopLevel { span: stmt.span });
                }

                self.enter_scope(ScopeKind::TypeAlias);
                let checked_generic_params = self.check_generic_params(&generic_params);
                let checked_value = self.check_type_annotation(&value);
                self.exit_scope();

                let decl = match self.scope_lookup(identifier.name) {
                    Some(SymbolEntry::TypeAliasDecl(decl)) => {
                        let mut mut_decl = decl.borrow_mut();
                        mut_decl.value = Box::new(checked_value);
                        mut_decl.generic_params = checked_generic_params;
                        mut_decl.span = stmt.span;
                        decl.clone()
                    }
                    _ => {
                        panic!("Expected type-alias declaration placeholder")
                    }
                };

                CheckedStmt::TypeAliasDecl(decl)
            }
            StmtKind::Break => {
                if !self.within_loop_scope() {
                    self.errors.push(SemanticError::BreakKeywordOutsideLoop { span: stmt.span });
                }

                CheckedStmt::Break { span: stmt.span }
            }
            StmtKind::Continue => {
                if !self.within_loop_scope() {
                    self.errors
                        .push(SemanticError::ContinueKeywordOutsideLoop { span: stmt.span });
                }

                CheckedStmt::Continue { span: stmt.span }
            }
            StmtKind::Return(expr) => {
                if !self.within_function_scope() {
                    self.errors
                        .push(SemanticError::ReturnKeywordOutsideFunction { span: stmt.span });
                }

                let value = self.check_expr(expr);

                CheckedStmt::Return(value)
            }
            StmtKind::Assignment { target, value } => {
                let checked_target = self.check_expr(target);
                let checked_value = self.check_expr(value);

                match &checked_target.kind {
                    CheckedExprKind::Identifier(id) => {
                        let symbol = self.scope_lookup(id.name);

                        if let Some(SymbolEntry::VarDecl(decl)) = symbol {
                            let decl = decl.borrow();

                            let is_assignable = self.check_is_assignable(&checked_value.ty, &decl.constraint);

                            if !is_assignable {
                                self.errors.push(SemanticError::TypeMismatch {
                                    expected: decl.constraint.clone(),
                                    received: checked_value.ty.clone(),
                                });
                            }
                        } else {
                            self.errors.push(SemanticError::UndeclaredIdentifier { id: *id });
                        }
                    }
                    // TODO: handle struct field assignments
                    _ => {
                        self.errors.push(SemanticError::InvalidAssignmentTarget {
                            target: checked_target.ty.clone(),
                        });
                    }
                }

                CheckedStmt::Assignment {
                    target: checked_target,
                    value: checked_value,
                }
            }
            StmtKind::From { path, identifiers } => CheckedStmt::From {
                identifiers,
                path,
                span: stmt.span,
            },
            StmtKind::While { condition, body } => {
                let checked_condition = self.check_expr(*condition);

                self.enter_scope(ScopeKind::While);
                let expected_condition_type = Type {
                    kind: TypeKind::Bool,
                    span: checked_condition.ty.span,
                };

                if !self.check_is_assignable(&checked_condition.ty, &expected_condition_type) {
                    self.errors.push(SemanticError::TypeMismatch {
                        expected: expected_condition_type,
                        received: checked_condition.ty.clone(),
                    });
                }

                let checked_final_expr = body.final_expr.map(|expr| Box::new(self.check_expr(*expr)));
                let checked_body_statements = self.check_stmts(body.statements);

                CheckedStmt::While {
                    condition: Box::new(checked_condition),
                    body: CheckedBlockContents {
                        final_expr: checked_final_expr,
                        statements: checked_body_statements,
                    },
                    span: stmt.span,
                }
            }
        }
    }
}

```

`WillowLang/src/ast/decl.rs`:

```rs
use crate::{ast::IdentifierNode, parse::DocAnnotation};

use super::{expr::Expr, type_annotation::TypeAnnotation};

#[derive(Clone, Debug, PartialEq)]
pub struct Param {
    pub identifier: IdentifierNode,
    pub constraint: TypeAnnotation,
}

#[derive(Clone, Debug, PartialEq)]
pub struct TypeAliasDecl {
    pub documentation: Option<DocAnnotation>,
    pub identifier: IdentifierNode,
    pub value: TypeAnnotation,
}

#[derive(Clone, Debug, PartialEq)]
pub struct StructDecl {
    pub documentation: Option<DocAnnotation>,
    pub identifier: IdentifierNode,
    pub fields: Vec<Param>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct EnumDeclVariant {
    pub name: IdentifierNode,
    pub payload: Option<TypeAnnotation>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct EnumDecl {
    pub documentation: Option<DocAnnotation>,
    pub identifier: IdentifierNode,
    pub variants: Vec<EnumDeclVariant>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct VarDecl {
    pub documentation: Option<DocAnnotation>,
    pub identifier: IdentifierNode,
    pub constraint: Option<TypeAnnotation>,
    pub value: Option<Expr>,
}

```

`WillowLang/src/ast/expr.rs`:

```rs
use std::hash::Hash;

use crate::{
    ast::{IdentifierNode, Span, StringNode},
    tokenize::NumberKind,
};

use super::{decl::Param, stmt::Stmt, type_annotation::TypeAnnotation};

#[derive(Clone, Debug, PartialEq)]
pub struct BlockContents {
    pub statements: Vec<Stmt>,
    pub final_expr: Option<Box<Expr>>,
    pub span: Span,
}

#[derive(Clone, Debug, PartialEq)]
pub enum MatchPattern {
    VariantWithValue(IdentifierNode, IdentifierNode), // e.g: match ... { Some(v) => .. }
    Variant(IdentifierNode),                          // e.g match ... { None => .. }
}

#[derive(Clone, Debug, PartialEq)]
pub struct MatchArm {
    pub pattern: Vec<MatchPattern>, // e.g match x, y, z { Foo(x), Bar, Baz(y) => {} }
    pub expression: Expr,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum BorrowKind {
    Mutable,
    Shared,
}

impl Hash for BorrowKind {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        std::mem::discriminant(self).hash(state);
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum ExprKind {
    Not {
        right: Box<Expr>,
    },
    Neg {
        right: Box<Expr>,
    },
    Add {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Subtract {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Multiply {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Divide {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Modulo {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    LessThan {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    LessThanOrEqual {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    GreaterThan {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    GreaterThanOrEqual {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Equal {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    NotEqual {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    And {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Or {
        left: Box<Expr>,
        right: Box<Expr>,
    },
    StructInit {
        left: Box<Expr>,
        fields: Vec<(IdentifierNode, Expr)>,
    },
    Access {
        left: Box<Expr>,
        field: IdentifierNode,
    },
    StaticAccess {
        left: Box<Expr>,
        field: IdentifierNode,
    },
    TypeCast {
        left: Box<Expr>,
        target: TypeAnnotation,
    },
    FnCall {
        left: Box<Expr>,
        args: Vec<Expr>,
    },
    Borrow {
        kind: BorrowKind,
        value: Box<Expr>,
    },
    BoolLiteral(bool),
    Number(NumberKind),
    String(StringNode),
    Identifier(IdentifierNode),
    Fn {
        name: IdentifierNode,
        params: Vec<Param>,
        return_type: TypeAnnotation,
        body: BlockContents,
    },
    Match {
        conditions: Vec<Expr>,
        arms: Vec<MatchArm>,
    },
    If {
        branches: Vec<(Box<Expr>, BlockContents)>,
        else_branch: Option<BlockContents>,
    },
    ListLiteral(Vec<Expr>),
    CodeBlock(BlockContents),
}

#[derive(Clone, Debug, PartialEq)]
pub struct Expr {
    pub kind: ExprKind,
    pub span: Span,
}

```

`WillowLang/src/ast/mod.rs`:

```rs
use std::hash::{Hash, Hasher};

use crate::compile::string_interner::InternerId;

pub mod decl;
pub mod expr;
pub mod stmt;
pub mod type_annotation;

#[derive(Debug, Clone, Copy)]
pub struct IdentifierNode {
    pub name: InternerId,
    pub span: Span,
}

impl Eq for IdentifierNode {}
impl PartialEq for IdentifierNode {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}
impl Hash for IdentifierNode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
    }
}

#[derive(Debug, Clone, Copy)]
pub struct StringNode {
    pub value: InternerId,
    pub len: usize,
    pub span: Span,
}

impl Eq for StringNode {}
impl PartialEq for StringNode {
    fn eq(&self, other: &Self) -> bool {
        self.value == other.value
    }
}
impl Hash for StringNode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.value.hash(state);
    }
}

#[derive(Clone, Debug, PartialEq, Copy, Default)]
pub struct Position {
    pub line: usize,
    pub col: usize,
    pub byte_offset: usize,
}

#[derive(Clone, Debug, PartialEq, Copy, Default)]
pub struct Span {
    pub start: Position,
    pub end: Position,
}

```

`WillowLang/src/ast/stmt.rs`:

```rs
use crate::ast::{
    decl::{EnumDecl, StructDecl},
    IdentifierNode, Span, StringNode,
};

use super::{
    decl::{TypeAliasDecl, VarDecl},
    expr::{BlockContents, Expr},
};

#[derive(Clone, Debug, PartialEq)]
pub enum StmtKind {
    Expression(Expr),
    TypeAliasDecl(TypeAliasDecl),
    VarDecl(VarDecl),
    StructDecl(StructDecl),
    EnumDecl(EnumDecl),
    Break,
    Continue,
    Return {
        value: Expr,
    },
    Assignment {
        target: Expr,
        value: Expr,
    },
    From {
        path: StringNode,
        identifiers: Vec<(IdentifierNode, Option<IdentifierNode>)>, // optional alias
    },
    While {
        condition: Box<Expr>,
        body: BlockContents,
    },
}

#[derive(Clone, Debug, PartialEq)]
pub struct Stmt {
    pub kind: StmtKind,
    pub span: Span,
}

```

`WillowLang/src/ast/type_annotation.rs`:

```rs
use crate::ast::{expr::BorrowKind, IdentifierNode, Span};

use super::decl::Param;

#[derive(Clone, Debug, PartialEq)]
pub enum TypeAnnotationKind {
    Void,
    Bool,
    U8,
    U16,
    U32,
    U64,
    USize,
    ISize,
    I8,
    I16,
    I32,
    I64,
    F32,
    F64,
    String,
    Identifier(IdentifierNode),
    Borrow {
        kind: BorrowKind,
        value: Box<TypeAnnotation>,
    },
    FnType {
        params: Vec<Param>,
        return_type: Box<TypeAnnotation>,
    },
}

#[derive(Clone, Debug, PartialEq)]
pub struct TypeAnnotation {
    pub kind: TypeAnnotationKind,
    pub span: Span,
}

```

`WillowLang/src/compile/mod.rs`:

```rs
use codespan_reporting::{
    diagnostic::{Diagnostic, Label},
    files::SimpleFiles,
    term::{
        self,
        termcolor::{ColorChoice, StandardStream},
    },
};
use string_interner::StringInterner;

pub mod string_interner;

use crate::{
    hir::{errors::SemanticErrorKind, utils::type_to_string::type_to_string, ModuleBuilder},
    parse::{Parser, ParsingErrorKind},
    tokenize::{token_kind_to_string, TokenizationErrorKind, Tokenizer},
};

pub fn compile_file<'a, 'b>(
    file_path: &'a str,
    source_code: &'a str,
    string_interner: &'b mut StringInterner<'a>,
    files: &mut SimpleFiles<usize, String>,
) {
    let interned_fp = string_interner.intern(file_path).0;
    files.add(interned_fp, source_code.to_string());

    let (tokens, tokenization_errors) = Tokenizer::tokenize(source_code);
    let (ast, parsing_errors) = Parser::parse(tokens, string_interner);
    let (analyzed_tree, semantic_errors) = ModuleBuilder::build(ast, file_path, string_interner);

    let mut errors: Vec<Diagnostic<usize>> = vec![];

    tokenization_errors.iter().for_each(|e| {
        let span = e.span.start.byte_offset..e.span.end.byte_offset;
        let label = Label::primary(interned_fp, span);
        let err = Diagnostic::error().with_code(format!("T{}", e.kind.code()));

        let diagnostic = match &e.kind {
            TokenizationErrorKind::UnterminatedString => err
                .with_message("Unterminated string")
                .with_label(label.with_message("This string is not terminated")),
            TokenizationErrorKind::UnknownToken => err
                .with_message("Unknown token")
                .with_label(label.with_message("This token is not recognized")),
            TokenizationErrorKind::UnknownEscapeSequence => err
                .with_message("Unknown escape sequence")
                .with_label(label.with_message("The escape sequence here is invalid")),
            TokenizationErrorKind::InvalidFloatingNumber => err
                .with_message("Invalid floating-point number")
                .with_label(label.with_message("This is not a valid floating-point number")),
            TokenizationErrorKind::InvalidIntegerNumber => err
                .with_message("Invalid integer number")
                .with_label(label.with_message("This is not a valid integer number")),
            TokenizationErrorKind::UnterminatedDoc => err
                .with_message("Unterminated documentation")
                .with_label(label.with_message("This documentation block is not terminated")),
        };

        errors.push(diagnostic);
    });

    parsing_errors.iter().for_each(|e| {
        let span = e.span.start.byte_offset..e.span.end.byte_offset;
        let label = Label::primary(interned_fp, span);
        let err = Diagnostic::error().with_code(format!("P{}", e.kind.code()));

        let diagnostic = match &e.kind {
            ParsingErrorKind::DocMustBeFollowedByDeclaration => err
                .with_message("Documentation must be followed by a declaration of ")
                .with_label(
                    label.with_message("This documentation must be followed by a declaration of a type alias or a variable"),
                ),
            ParsingErrorKind::ExpectedAnExpressionButFound(token) => {
                err.with_message("Expected an expression")
                    .with_label(label.with_message(format!(
                        "Expected an expression but instead found token \"{}\"",
                        token_kind_to_string(&token.kind)
                    )))
            }
            ParsingErrorKind::ExpectedATypeButFound(token) => {
                err.with_message("Expected a type").with_label(label.with_message(format!(
                    "Expected a type but instead found token \"{}\"",
                    token_kind_to_string(&token.kind)
                )))
            }
            ParsingErrorKind::InvalidSuffixOperator(token) => {
                err.with_message("Invalid suffix operator")
                    .with_label(label.with_message(format!(
                        "Invalid token as expression suffix operator \"{}\"",
                        token_kind_to_string(&token.kind)
                    )))
            }
            ParsingErrorKind::UnexpectedEndOfInput => err
                .with_message("Unexpected end of input")
                .with_label(label.with_message("Unexpected end of input")),
            ParsingErrorKind::ExpectedAnIdentifier => err
                .with_message("Expected an identifier")
                .with_label(label.with_message("Expected an identifier")),
            ParsingErrorKind::ExpectedAPunctuationMark(punctuation_kind) => err
                .with_message("Expected a punctuation mark")
                .with_label(label.with_message(format!("Expected the \"{}\" punctuation mark", punctuation_kind.to_string()))),
            ParsingErrorKind::ExpectedAKeyword(keyword_kind) => err
                .with_message("Expected a keyword")
                .with_label(label.with_message(format!("Expected the \"{}\" keyword", keyword_kind.to_string()))),
            ParsingErrorKind::ExpectedAStringValue => err
                .with_message("Expected a string literal")
                .with_label(label.with_message("Expected a string literal")),
            ParsingErrorKind::ExpectedANumericValue => err
                .with_message("Expected a numeric literal")
                .with_label(label.with_message("Expected a numeric literal")),
            ParsingErrorKind::UnknownStaticMethod(identifier_node) => {
                let name = string_interner.resolve(identifier_node.name);
                err.with_message("Unknown static method")
                    .with_label(label.with_message(format!("Static method with name \"{}\" doesn't exist", name)))
            }
            ParsingErrorKind::UnexpectedStatementAfterFinalExpression => err
                .with_message("Unexpected statement after final expression")
                .with_label(label.with_message("Final expression of a codeblock must not be followed by another statement")),
            ParsingErrorKind::ExpectedStatementOrExpression { found } => err
                .with_message("Expected a statement or an expression")
                .with_label(label.with_message(format!(
                    "Expected a statement or an expression but instead found token \"{}\"",
                    token_kind_to_string(found)
                ))),
            ParsingErrorKind::UnexpectedTokenAfterFinalExpression { found } => err
                .with_message("Unexpected token after final expression")
                .with_label(label.with_message(format!(
                    "Unexpected token \"{}\" after final expression",
                    token_kind_to_string(found)
                ))),
            ParsingErrorKind::ExpectedATagTypeButFound(type_annotation) => todo!(),
        };

        errors.push(diagnostic);
    });

    semantic_errors.into_iter().for_each(|e| {
        let span = e.span();
        let error_span = span.start.byte_offset..span.end.byte_offset;
        let label = Label::primary(interned_fp, error_span);
        let err = Diagnostic::error().with_code(format!("S{}", e.code()));

        let diagnostic = match &e {
            SemanticErrorKind::ExpectedANumericOperand { .. } => err
                .with_message("Expected a numeric operand")
                .with_label(label.with_message("Expected this value to have a numeric type")),
            SemanticErrorKind::MixedSignedAndUnsigned { .. } => err
                .with_message("Mixed signed and unsigned operands")
                .with_label(label.with_message("Mixing signed and unsigned operands in an arithmetic operation is not allowed")),
            SemanticErrorKind::MixedFloatAndInteger { .. } => err.with_message("Mixed float and integer operands").with_label(
                label.with_message("Mixing integer and floating-point numbers in an arithmetic operation is not allowed"),
            ),
            SemanticErrorKind::CannotCompareType { of, to } => {
                err.with_message("Cannot compare types")
                    .with_label(label.with_message(format!(
                        "Cannot compare type \"{}\" to type \"{}\"",
                        type_to_string(&of.kind, string_interner),
                        type_to_string(&to.kind, string_interner)
                    )))
            }
            SemanticErrorKind::UndeclaredIdentifier(id) => {
                let name = string_interner.resolve(id.name);

                err.with_message("Undeclared identifier")
                    .with_label(label.with_message(format!("Undeclared identifier \"{}\"", name)))
            }
            SemanticErrorKind::UndeclaredType(id) => {
                let name = string_interner.resolve(id.name);

                err.with_message("Undeclared type")
                    .with_label(label.with_message(format!("Undeclared type \"{}\"", name)))
            }
            SemanticErrorKind::ReturnKeywordOutsideFunction { .. } => err
                .with_message("Keyword \"return\" used outside of a function scope")
                .with_label(label.with_message("Cannot use the \"return\" keyword outside of a function scope")),
            SemanticErrorKind::BreakKeywordOutsideLoop { .. } => err
                .with_message("Keyword \"break\" used outside of a loop scope")
                .with_label(label.with_message("Cannot use the \"break\" keyword outside of a loop scope")),
            SemanticErrorKind::ContinueKeywordOutsideLoop { .. } => err
                .with_message("Keyword \"continue\" used outside of a loop scope")
                .with_label(label.with_message("Cannot use the \"continue\" keyword outside of a loop scope")),
            SemanticErrorKind::InvalidLValue { .. } => err
                .with_message("Invalid assignment target")
                .with_label(label.with_message("Invalid assignment target")),
            SemanticErrorKind::TypeMismatch { expected, received } => {
                let constraint_str = type_to_string(&expected.kind, string_interner);
                let declaration_of_expected = expected.span.start.byte_offset..expected.span.end.byte_offset;

                err.with_message("Type mismatch").with_labels(vec![
                    label.with_message(format!(
                        "Type mismatch, expected `{}`, instead found `{}`",
                        constraint_str,
                        type_to_string(&received.kind, string_interner)
                    )),
                    Label::secondary(interned_fp, declaration_of_expected)
                        .with_message(format!("expected type \"{}\" originated here", constraint_str)),
                ])
            }
            SemanticErrorKind::ReturnNotLastStatement { .. } => err
                .with_message("Expected the return statement to be the last statement in the function")
                .with_label(label.with_message("Expected the return statement to be the last statement in the function")),
            SemanticErrorKind::ReturnTypeMismatch { expected, received } => {
                err.with_message("Return type mismatch")
                    .with_label(label.with_message(format!(
                        "Expected the return value to be assignable to {}, found {}",
                        type_to_string(&expected.kind, string_interner),
                        type_to_string(&received.kind, string_interner)
                    )))
            }
            SemanticErrorKind::CannotAccess(target) => {
                err.with_message("Cannot access field").with_label(label.with_message(format!(
                    "Cannot use the access operator on the type \"{}\"",
                    type_to_string(&target.kind, string_interner)
                )))
            }
            SemanticErrorKind::CannotCall(target) => {
                err.with_message("Cannot use the function call operator")
                    .with_label(label.with_message(format!(
                        "Cannot use the function-call operator on type \"{}\"",
                        type_to_string(&target.kind, string_interner)
                    )))
            }
            SemanticErrorKind::FnArgumentCountMismatch { expected, received, .. } => {
                let s = if expected > 1 { "s" } else { "" };
                err.with_message("Function argument count mismatch")
                    .with_label(label.with_message(format!(
                        "This function expects {} argument{}, but instead received {}",
                        expected.to_string(),
                        s,
                        received.to_string()
                    )))
            }
            SemanticErrorKind::CannotUseVariableDeclarationAsType { .. } => err
                .with_message("Cannot use variable declaration as a type")
                .with_label(label.with_message("Cannot use variable declaration as a type")),
            SemanticErrorKind::AccessToUndefinedField(field) => {
                let name = string_interner.resolve(field.name);
                err.with_message("Access to an undefined field")
                    .with_label(label.with_message(format!("Field {} is not defined", name)))
            }
            SemanticErrorKind::TypeAliasMustBeDeclaredAtTopLevel { .. } => err
                .with_message("Type aliases must be declared in the file scope")
                .with_label(label.with_message("Type aliases must be declared in the file scope")),
            SemanticErrorKind::StructMustBeDeclaredAtTopLevel { .. } => err
                .with_message("Structs must be declared in the file scope")
                .with_label(label.with_message("Structs must be declared in the file scope")),
            SemanticErrorKind::DuplicateStructFieldInitializer(id) => {
                let name = string_interner.resolve(id.name);
                err.with_message("Duplicate initializer for a struct field")
                    .with_label(label.with_message(format!("Struct field \"{}\" cannot be initialized multiple times", name)))
            }
            SemanticErrorKind::UnknownStructFieldInitializer(id) => {
                let name = string_interner.resolve(id.name);
                err.with_message("Unknown field in the struct initializer")
                    .with_label(label.with_message(format!("Unknown struct field \"{}\"", name)))
            }
            SemanticErrorKind::MissingStructFieldInitializers(missing_fields) => {
                let field_names: Vec<&'a str> = missing_fields.into_iter().map(|f| string_interner.resolve(f)).collect();
                let joined = field_names
                    .iter()
                    .map(|n| format!("\"{}\"", n))
                    .collect::<Vec<String>>()
                    .join(", ");
                err.with_message("Missing field initializers")
                    .with_label(label.with_message(format!("Missing initializers for the following struct fields {}", joined)))
            }
            SemanticErrorKind::CannotApplyStructInitializer { .. } => err
                .with_message("Cannot apply struct initializer")
                .with_label(label.with_message("Cannot apply struct initializer to this expression")),
            SemanticErrorKind::VarDeclWithoutInitializer { .. } => err
                .with_message("Variable declarations must have an initializer")
                .with_label(label.with_message("This variable declaration must have an initializer")),
            SemanticErrorKind::DuplicateIdentifier(id) => {
                let identifier_name = string_interner.resolve(id.name);
                err.with_message("Duplicate identifier")
                    .with_label(label.with_message(format!("Duplicate identifier declaration \"{}\"", identifier_name)))
            }
            SemanticErrorKind::CannotIndex(_) => todo!(),
            SemanticErrorKind::IncompatibleBranchTypes { first, second } => todo!(),
            SemanticErrorKind::ExpectedEnumType => todo!(),
            SemanticErrorKind::TypeMismatchExpectedOneOf { expected, received } => todo!(),
            SemanticErrorKind::CannotStaticAccess(_) => todo!(),
            SemanticErrorKind::ExpectedAType => todo!(),
            SemanticErrorKind::AccessToUndefinedStaticField(identifier_node) => todo!(),
            SemanticErrorKind::IfExpressionMissingElse => todo!(),
            SemanticErrorKind::CannotCastType {
                source_type,
                target_type,
            } => todo!(),
        };

        errors.push(diagnostic);
    });

    let writer = StandardStream::stderr(ColorChoice::Always);
    let mut config = codespan_reporting::term::Config::default();

    config.start_context_lines = 8;
    config.end_context_lines = 8;
    config.before_label_lines = 8;
    config.after_label_lines = 8;

    if !errors.is_empty() {
        println!();
        for diagnostic in errors {
            let _ = term::emit(&mut writer.lock(), &config, files, &diagnostic);
        }
    } else {
        println!("Compilation successful for {} (no errors found).", file_path);
    }
}

```

`WillowLang/src/compile/string_interner.rs`:

```rs
use std::collections::{hash_map::Entry, HashMap};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct InternerId(pub usize);

#[derive(Debug, Clone)]
pub struct StringInterner<'a> {
    pub forward: HashMap<&'a str, usize>,
    backward: Vec<&'a str>,
    next_id: usize,
}

impl<'a> StringInterner<'a> {
    pub fn new() -> StringInterner<'a> {
        StringInterner {
            forward: HashMap::new(),
            backward: vec![],
            next_id: 0,
        }
    }

    pub fn from(value: impl IntoIterator<Item = &'a str>) -> StringInterner<'a> {
        let mut interner = Self::new();

        value.into_iter().for_each(|v| {
            interner.intern(v);
        });

        interner
    }

    pub fn intern(&mut self, key: &'a str) -> InternerId {
        match self.forward.entry(key) {
            Entry::Occupied(v) => InternerId(*v.get()),
            Entry::Vacant(e) => {
                let id = self.next_id;

                e.insert(id);
                self.backward.push(key);

                self.next_id += 1;
                InternerId(id)
            }
        }
    }

    pub fn resolve(&self, key: InternerId) -> &'a str {
        self.backward.get(key.0).map(|v| *v).expect(&format!(
            "INTERNAL COMPILER ERROR: string interner expected key {} to exist",
            key.0
        ))
    }
}

```

`WillowLang/src/hir/cfg.rs`:

```rs
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
};

use crate::{
    ast::IdentifierNode,
    compile::string_interner::InternerId,
    hir::types::{
        checked_declaration::{CheckedEnumDecl, CheckedStructDecl, CheckedTypeAliasDecl, CheckedVarDecl},
        checked_type::Type,
    },
    tokenize::NumberKind,
};

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ModuleId(pub usize);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct FunctionId(pub usize);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BasicBlockId(pub usize);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct HeapAllocationId(pub usize);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ValueId(pub usize);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct ConstantId(pub usize);

#[derive(Clone, Debug)]
pub enum Value {
    VoidLiteral,
    BoolLiteral(bool),
    NumberLiteral(NumberKind),
    StringLiteral(InternerId),
    FunctionAddr { function_id: FunctionId, ty: Type },
    Use(ValueId),
}

#[derive(Clone, Debug)]
pub enum PtrOffset {
    // A dynamic offset, calculated at runtime.
    Dynamic(Value),
    // A constant offset, known at compile time.
    Constant(usize),
}

#[derive(Clone, Debug)]
pub enum Instruction {
    StackAlloc {
        destination: ValueId,
        count: usize,
    },
    HeapAlloc {
        destination: ValueId,
        allocation_site_id: HeapAllocationId,
        count: Value,
    },
    Store {
        destination_ptr: ValueId,
        source_val: Value,
    },
    Load {
        destination: ValueId,
        source_ptr: ValueId,
    },
    GetFieldPtr {
        destination: ValueId,
        base_ptr: ValueId,
        field_index: usize,
    },
    PtrAdd {
        destination: ValueId,
        base_ptr: ValueId,
        // The index is now this more explicit enum.
        offset: PtrOffset,
    },
    UnaryOp {
        op_kind: UnaryOperationKind,
        destination: ValueId,
        operand: Value,
    },
    BinaryOp {
        op_kind: BinaryOperationKind,
        destination: ValueId,
        left: Value,
        right: Value,
    },
    TypeCast {
        destination: ValueId,
        operand: Value,
        target_type: Type,
    },
    FunctionCall {
        destination: Option<ValueId>,
        function_rvalue: Value,
        args: Vec<Value>,
    },
    Phi {
        destination: ValueId,
        sources: Vec<(BasicBlockId, Value)>,
    },
    Nop,
}

#[derive(Clone, Debug)]
pub enum UnaryOperationKind {
    Not,
    Neg,
}

#[derive(Clone, Debug)]
pub enum BinaryOperationKind {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulo,
    LessThan,
    LessThanOrEqual,
    GreaterThan,
    GreaterThanOrEqual,
    Equal,
    NotEqual,
}

#[derive(Clone, Debug)]
pub enum Terminator {
    Jump {
        target: BasicBlockId,
    },
    CondJump {
        condition: Value,
        true_target: BasicBlockId,
        false_target: BasicBlockId,
    },
    Return {
        value: Option<Value>,
    },
    Unreachable,
}

#[derive(Clone, Debug)]
pub struct BasicBlock {
    pub id: BasicBlockId,
    pub instructions: Vec<Instruction>,
    pub terminator: Terminator,
}

#[derive(Clone, Debug)]
pub struct ControlFlowGraph {
    pub entry_block: BasicBlockId,
    pub blocks: HashMap<BasicBlockId, BasicBlock>,
}

#[derive(Clone, Debug)]
pub enum CheckedDeclaration {
    TypeAliasDecl(CheckedTypeAliasDecl),
    StructDecl(CheckedStructDecl),
    VarDecl(CheckedVarDecl),
    EnumDecl(CheckedEnumDecl),
}

#[derive(Clone, Debug)]
pub struct CheckedModule {
    pub id: ModuleId,
    pub name: PathBuf,
    pub functions: HashMap<FunctionId, ControlFlowGraph>,
    pub constant_data: HashMap<ConstantId, Vec<u8>>, // map: id -> bytes
    pub declarations: HashMap<IdentifierNode, CheckedDeclaration>,
    pub exports: HashSet<IdentifierNode>,
}

impl CheckedModule {
    pub fn new(id: ModuleId, name: PathBuf) -> Self {
        Self {
            id,
            name,
            declarations: HashMap::new(),
            constant_data: HashMap::new(),
            exports: HashSet::new(),
            functions: HashMap::new(),
        }
    }
}

```

`WillowLang/src/hir/errors.rs`:

```rs
use std::collections::HashSet;

use crate::{
    ast::{IdentifierNode, Span},
    compile::string_interner::InternerId,
    hir::types::checked_type::Type,
};

#[derive(Debug, Clone)]
pub enum SemanticErrorKind {
    DuplicateIdentifier(IdentifierNode),
    CannotIndex(Type),
    VarDeclWithoutInitializer,
    DuplicateStructFieldInitializer(IdentifierNode),
    UnknownStructFieldInitializer(IdentifierNode),
    MissingStructFieldInitializers(HashSet<InternerId>),
    CannotCall(Type),
    CannotApplyStructInitializer,
    ExpectedANumericOperand,
    IncompatibleBranchTypes { first: Type, second: Type },
    MixedSignedAndUnsigned,
    MixedFloatAndInteger,
    ExpectedEnumType,
    CannotCompareType { of: Type, to: Type },
    UndeclaredIdentifier(IdentifierNode),
    UndeclaredType(IdentifierNode),
    ReturnKeywordOutsideFunction,
    BreakKeywordOutsideLoop,
    ContinueKeywordOutsideLoop,
    InvalidLValue,
    TypeMismatch { expected: Type, received: Type },
    TypeMismatchExpectedOneOf { expected: HashSet<Type>, received: Type },
    ReturnNotLastStatement,
    ReturnTypeMismatch { expected: Type, received: Type },
    CannotAccess(Type),
    CannotStaticAccess(Type),
    AccessToUndefinedField(IdentifierNode),
    AccessToUndefinedStaticField(IdentifierNode),
    ExpectedAType,
    FnArgumentCountMismatch { expected: usize, received: usize },
    CannotUseVariableDeclarationAsType,
    TypeAliasMustBeDeclaredAtTopLevel,
    StructMustBeDeclaredAtTopLevel,
    IfExpressionMissingElse,
    CannotCastType { source_type: Type, target_type: Type },
}

#[derive(Debug, Clone)]
pub struct SemanticError {
    pub kind: SemanticErrorKind,
    pub span: Span,
}

impl SemanticErrorKind {
    pub fn code(&self) -> usize {
        match self {
            SemanticErrorKind::ExpectedANumericOperand { .. } => 1,
            SemanticErrorKind::MixedSignedAndUnsigned { .. } => 2,
            SemanticErrorKind::MixedFloatAndInteger { .. } => 3,
            SemanticErrorKind::CannotCompareType { .. } => 4,
            SemanticErrorKind::UndeclaredIdentifier { .. } => 5,
            SemanticErrorKind::ReturnKeywordOutsideFunction { .. } => 6,
            SemanticErrorKind::BreakKeywordOutsideLoop { .. } => 7,
            SemanticErrorKind::ContinueKeywordOutsideLoop { .. } => 8,
            SemanticErrorKind::InvalidLValue { .. } => 9,
            SemanticErrorKind::TypeMismatch { .. } => 10,
            SemanticErrorKind::ReturnNotLastStatement { .. } => 11,
            SemanticErrorKind::ReturnTypeMismatch { .. } => 12,
            SemanticErrorKind::UndeclaredType { .. } => 13,
            SemanticErrorKind::CannotAccess { .. } => 14,
            SemanticErrorKind::CannotCall { .. } => 15,
            SemanticErrorKind::CannotUseVariableDeclarationAsType { .. } => 16,
            SemanticErrorKind::VarDeclWithoutInitializer { .. } => 17,
            SemanticErrorKind::AccessToUndefinedField { .. } => 18,
            SemanticErrorKind::FnArgumentCountMismatch { .. } => 19,
            SemanticErrorKind::TypeAliasMustBeDeclaredAtTopLevel { .. } => 20,
            SemanticErrorKind::StructMustBeDeclaredAtTopLevel { .. } => 21,
            SemanticErrorKind::DuplicateStructFieldInitializer { .. } => 22,
            SemanticErrorKind::UnknownStructFieldInitializer { .. } => 23,
            SemanticErrorKind::MissingStructFieldInitializers { .. } => 24,
            SemanticErrorKind::CannotApplyStructInitializer { .. } => 25,
            SemanticErrorKind::DuplicateIdentifier { .. } => 26,
            SemanticErrorKind::IncompatibleBranchTypes { .. } => 27,
            SemanticErrorKind::IfExpressionMissingElse => 28,
            SemanticErrorKind::TypeMismatchExpectedOneOf { .. } => 29,
            SemanticErrorKind::ExpectedEnumType => 30,
            SemanticErrorKind::CannotCastType { .. } => 31,
            SemanticErrorKind::CannotIndex { .. } => 32,
            SemanticErrorKind::CannotStaticAccess { .. } => 33,
            SemanticErrorKind::ExpectedAType => 34,
            SemanticErrorKind::AccessToUndefinedStaticField { .. } => 35,
        }
    }
}

```

`WillowLang/src/hir/expressions/access.rs`:

```rs
use crate::{
    ast::{expr::Expr, IdentifierNode},
    hir::{cfg::Value, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_access_expr(&mut self, ctx: &mut HIRContext, left: Box<Expr>, field: IdentifierNode) -> Value {
        let base_ptr_id = match self.build_lvalue_expr(ctx, *left) {
            Ok(id) => id,
            Err(e) => return Value::Use(self.report_error_and_get_poison(ctx, e)),
        };

        let field_ptr_id = match self.emit_get_field_ptr(ctx, base_ptr_id, field) {
            Ok(id) => id,
            Err(e) => return Value::Use(self.report_error_and_get_poison(ctx, e)),
        };

        let final_value_id = self.emit_load(ctx, field_ptr_id);

        Value::Use(final_value_id)
    }
}

```

`WillowLang/src/hir/expressions/and.rs`:

```rs
use crate::{
    ast::expr::Expr,
    hir::{
        cfg::{Terminator, Value},
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_and_expr(&mut self, ctx: &mut HIRContext, left: Box<Expr>, right: Box<Expr>) -> Value {
        let right_entry_block_id = self.new_basic_block();
        let merge_block_id = self.new_basic_block();

        let left_value = self.build_expr(ctx, *left);
        let left_exit_block_id = self.current_block_id;

        self.set_basic_block_terminator(Terminator::CondJump {
            condition: left_value,
            true_target: right_entry_block_id,
            false_target: merge_block_id,
        });

        self.use_basic_block(right_entry_block_id);
        let right_value = self.build_expr(ctx, *right);
        let right_exit_block_id = self.current_block_id;
        self.set_basic_block_terminator(Terminator::Jump { target: merge_block_id });

        self.use_basic_block(merge_block_id);
        let phi_sources = vec![
            (left_exit_block_id, Value::BoolLiteral(false)),
            (right_exit_block_id, right_value),
        ];

        let phi_destination = match self.emit_phi(ctx, phi_sources) {
            Ok(phi_destination) => phi_destination,
            Err(err) => self.report_error_and_get_poison(ctx, err),
        };

        Value::Use(phi_destination)
    }
}

```

`WillowLang/src/hir/expressions/binary_op.rs`:

```rs
use crate::{
    ast::expr::Expr,
    hir::{
        cfg::{BinaryOperationKind, Value},
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_binary_op_expr(
        &mut self,
        ctx: &mut HIRContext,
        left: Box<Expr>,
        right: Box<Expr>,
        op_kind: BinaryOperationKind,
    ) -> Value {
        let left_value = self.build_expr(ctx, *left);
        let right_value = self.build_expr(ctx, *right);
        let destination = match self.emit_binary_op(ctx, op_kind, left_value, right_value) {
            Ok(destination_id) => destination_id,
            Err(error) => {
                return Value::Use(self.report_error_and_get_poison(ctx, error));
            }
        };

        Value::Use(destination)
    }
}

```

`WillowLang/src/hir/expressions/bool_literal.rs`:

```rs
use crate::hir::{cfg::Value, FunctionBuilder};

impl FunctionBuilder {
    pub fn build_bool_literal(&mut self, value: bool) -> Value {
        Value::BoolLiteral(value)
    }
}

```

`WillowLang/src/hir/expressions/codeblock.rs`:

```rs
use crate::{
    ast::expr::BlockContents,
    hir::{cfg::Value, utils::scope::ScopeKind, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_codeblock_expr(&mut self, ctx: &mut HIRContext, codeblock: BlockContents) -> Value {
        ctx.module_builder.enter_scope(ScopeKind::CodeBlock);
        self.build_statements(ctx, codeblock.statements);

        let result_value = if let Some(final_expr) = codeblock.final_expr {
            self.build_expr(ctx, *final_expr)
        } else {
            Value::VoidLiteral
        };

        ctx.module_builder.exit_scope();

        result_value
    }
}

```

`WillowLang/src/hir/expressions/fn.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/expressions/fn_call.rs`:

```rs
use crate::{
    ast::{expr::Expr, Span},
    hir::{cfg::Value, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_fn_call_expr(&mut self, ctx: &mut HIRContext, left: Box<Expr>, args: Vec<Expr>, span: Span) -> Value {
        let function_value = self.build_expr(ctx, *left);

        let arg_values: Vec<Value> = args.into_iter().map(|arg_expr| self.build_expr(ctx, arg_expr)).collect();

        match self.emit_function_call(ctx, function_value, arg_values, span) {
            Ok(Some(return_value_id)) => Value::Use(return_value_id),
            Ok(None) => Value::VoidLiteral,
            Err(e) => Value::Use(self.report_error_and_get_poison(ctx, e)),
        }
    }
}

```

`WillowLang/src/hir/expressions/identifier.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/expressions/if.rs`:

```rs
use crate::{
    ast::expr::{BlockContents, Expr},
    hir::{
        cfg::{BasicBlockId, Terminator, Value},
        errors::{SemanticError, SemanticErrorKind},
        types::checked_type::{Type, TypeKind},
        FunctionBuilder, HIRContext,
    },
};

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum IfContext {
    /// The `if` is used to produce a value.
    Expression,
    /// The `if` is used for control flow; its value is discarded.
    Statement,
}

impl FunctionBuilder {
    pub fn build_if(
        &mut self,
        ctx: &mut HIRContext,
        branches: Vec<(Box<Expr>, BlockContents)>,
        else_branch: Option<BlockContents>,
        context: IfContext,
    ) -> Value {
        if context == IfContext::Expression && else_branch.is_none() {
            let span = branches.first().unwrap().0.span;
            return Value::Use(self.report_error_and_get_poison(
                ctx,
                SemanticError {
                    kind: SemanticErrorKind::IfExpressionMissingElse,
                    span,
                },
            ));
        }

        let entry_block_id = self.current_block_id;
        let merge_block_id = self.new_basic_block();

        let mut phi_sources: Vec<(BasicBlockId, Value, Type)> = Vec::new();
        let mut current_block_id = entry_block_id;

        for (condition, body) in branches {
            let expected_condition_type = Type {
                kind: TypeKind::Bool,
                span: condition.span,
            };

            self.use_basic_block(current_block_id);

            let condition_value = self.build_expr(ctx, *condition);
            let condition_value_type = ctx.program_builder.get_value_type(&condition_value);

            if !self.check_is_assignable(&condition_value_type, &expected_condition_type) {
                return Value::Use(self.report_error_and_get_poison(
                    ctx,
                    SemanticError {
                        span: condition_value_type.span,
                        kind: SemanticErrorKind::TypeMismatch {
                            expected: expected_condition_type,
                            received: condition_value_type,
                        },
                    },
                ));
            }

            let body_block_id = self.new_basic_block();
            let next_condition_block_id = self.new_basic_block();

            self.set_basic_block_terminator(Terminator::CondJump {
                condition: condition_value,
                true_target: body_block_id,
                false_target: next_condition_block_id,
            });

            self.use_basic_block(body_block_id);
            let body_value = self.build_codeblock_expr(ctx, body);
            let body_type = ctx.program_builder.get_value_type(&body_value);
            let body_exit_block_id = self.current_block_id;
            phi_sources.push((body_exit_block_id, body_value, body_type));
            self.set_basic_block_terminator(Terminator::Jump { target: merge_block_id });

            current_block_id = next_condition_block_id;
        }

        self.use_basic_block(current_block_id);
        if let Some(else_body) = else_branch {
            let else_value = self.build_codeblock_expr(ctx, else_body);
            let else_type = ctx.program_builder.get_value_type(&else_value);
            let else_exit_block_id = self.current_block_id;
            phi_sources.push((else_exit_block_id, else_value, else_type));
        }
        self.set_basic_block_terminator(Terminator::Jump { target: merge_block_id });

        self.use_basic_block(merge_block_id);

        if context == IfContext::Expression {
            let sources_for_phi: Vec<(BasicBlockId, Value)> = phi_sources.into_iter().map(|(id, val, _)| (id, val)).collect();

            let phi_destination = match self.emit_phi(ctx, sources_for_phi) {
                Ok(id) => id,
                Err(e) => return Value::Use(self.report_error_and_get_poison(ctx, e)),
            };

            Value::Use(phi_destination)
        } else {
            Value::VoidLiteral
        }
    }
}

```

`WillowLang/src/hir/expressions/list_literal.rs`:

```rs
use crate::{
    ast::expr::Expr,
    hir::{cfg::Value, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_list_literal_expr(&mut self, ctx: &mut HIRContext, items: Vec<Expr>) -> Value {
        todo!()
    }
}

```

`WillowLang/src/hir/expressions/match.rs`:

```rs
use crate::{
    ast::expr::{Expr, MatchArm},
    hir::{cfg::Value, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_match_expr(&mut self, ctx: &mut HIRContext, conditions: Vec<Expr>, arms: Vec<MatchArm>) -> Value {
        todo!()
    }
}

```

`WillowLang/src/hir/expressions/mod.rs`:

```rs
pub mod access;
pub mod and;
pub mod binary_op;
pub mod bool_literal;
pub mod codeblock;
pub mod r#fn;
pub mod fn_call;
pub mod identifier;
pub mod r#if;
pub mod list_literal;
pub mod r#match;
pub mod number_literal;
pub mod or;
pub mod static_access;
pub mod string;
pub mod struct_init;
pub mod typecast;
pub mod unary_op;

use crate::{
    ast::expr::{Expr, ExprKind},
    hir::{
        cfg::{BinaryOperationKind, UnaryOperationKind, Value},
        expressions::r#if::IfContext,
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_expr(&mut self, ctx: &mut HIRContext, expr: Expr) -> Value {
        match expr.kind {
            ExprKind::Not { right } => self.build_unary_op_expr(ctx, UnaryOperationKind::Not, right),
            ExprKind::Neg { right } => self.build_unary_op_expr(ctx, UnaryOperationKind::Neg, right),
            ExprKind::Add { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::Add),
            ExprKind::Subtract { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::Subtract),
            ExprKind::Multiply { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::Multiply),
            ExprKind::Divide { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::Divide),
            ExprKind::Modulo { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::Modulo),
            ExprKind::LessThan { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::LessThan),
            ExprKind::LessThanOrEqual { left, right } => {
                self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::LessThanOrEqual)
            }
            ExprKind::GreaterThan { left, right } => {
                self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::GreaterThan)
            }
            ExprKind::GreaterThanOrEqual { left, right } => {
                self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::GreaterThanOrEqual)
            }
            ExprKind::Equal { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::Equal),
            ExprKind::NotEqual { left, right } => self.build_binary_op_expr(ctx, left, right, BinaryOperationKind::NotEqual),
            ExprKind::And { left, right } => self.build_and_expr(ctx, left, right),
            ExprKind::Or { left, right } => self.build_or_expr(ctx, left, right),
            ExprKind::Access { left, field } => self.build_access_expr(ctx, left, field),
            ExprKind::StaticAccess { left, field } => todo!(),
            ExprKind::TypeCast { left, target } => self.build_typecast_expr(ctx, left, target),
            ExprKind::FnCall { left, args } => self.build_fn_call_expr(ctx, left, args, expr.span),
            ExprKind::BoolLiteral(value) => self.build_bool_literal(value),
            ExprKind::Number(value) => self.build_number_literal(value),
            ExprKind::String(value) => todo!(),
            ExprKind::Identifier(identifier) => todo!(),
            ExprKind::Fn {
                params,
                body,
                return_type,
                name,
            } => todo!(),
            ExprKind::If { branches, else_branch } => self.build_if(ctx, branches, else_branch, IfContext::Expression),
            ExprKind::ListLiteral(items) => self.build_list_literal_expr(ctx, items),
            ExprKind::CodeBlock(block_contents) => self.build_codeblock_expr(ctx, block_contents),
            ExprKind::Match { conditions, arms } => self.build_match_expr(ctx, conditions, arms),
            ExprKind::StructInit { left, fields } => self.build_struct_init_expr(ctx, left, fields),
            ExprKind::Borrow { kind, value } => todo!(),
        }
    }
}

```

`WillowLang/src/hir/expressions/number_literal.rs`:

```rs
use crate::{
    hir::{cfg::Value, FunctionBuilder},
    tokenize::NumberKind,
};

impl FunctionBuilder {
    pub fn build_number_literal(&mut self, value: NumberKind) -> Value {
        Value::NumberLiteral(value)
    }
}

```

`WillowLang/src/hir/expressions/or.rs`:

```rs
use crate::{
    ast::expr::Expr,
    hir::{
        cfg::{Terminator, Value},
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_or_expr(&mut self, ctx: &mut HIRContext, left: Box<Expr>, right: Box<Expr>) -> Value {
        let merge_block_id = self.new_basic_block();
        let right_entry_block_id = self.new_basic_block();

        let left_value = self.build_expr(ctx, *left);
        let left_exit_block_id = self.current_block_id;

        self.set_basic_block_terminator(Terminator::CondJump {
            condition: left_value,
            true_target: merge_block_id,
            false_target: right_entry_block_id,
        });

        self.use_basic_block(right_entry_block_id);
        let right_value = self.build_expr(ctx, *right);
        let right_exit_block_id = self.current_block_id;
        self.set_basic_block_terminator(Terminator::Jump { target: merge_block_id });

        self.use_basic_block(merge_block_id);
        let phi_sources = vec![
            (left_exit_block_id, Value::BoolLiteral(true)),
            (right_exit_block_id, right_value),
        ];

        let phi_destination = match self.emit_phi(ctx, phi_sources) {
            Ok(phi_destination) => phi_destination,
            Err(err) => self.report_error_and_get_poison(ctx, err),
        };

        Value::Use(phi_destination)
    }
}

```

`WillowLang/src/hir/expressions/static_access.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/expressions/string.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/expressions/struct_init.rs`:

```rs
use std::collections::HashSet;

use crate::{
    ast::{
        expr::{Expr, ExprKind},
        IdentifierNode,
    },
    compile::string_interner::InternerId,
    hir::{
        cfg::Value,
        errors::{SemanticError, SemanticErrorKind},
        types::{
            checked_declaration::CheckedStructDecl,
            checked_type::{Type, TypeKind},
        },
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_capture_struct_for_fn(&mut self) -> CheckedStructDecl {
        todo!()
    }

    fn evaluate_expression_with_type_tail(&mut self, ctx: &mut HIRContext, expr: Expr) -> Result<Type, SemanticError> {
        let expr_span = expr.span;
        match expr.kind {
            ExprKind::Identifier(id) => Ok(Type {
                span: expr.span,
                kind: self.check_type_identifier_annotation(ctx, id, expr.span)?,
            }),
            ExprKind::StaticAccess { left, field } => {
                let left_span = left.span;
                let left_type = self.evaluate_expression_with_type_tail(ctx, *left)?;

                match left_type.kind {
                    TypeKind::FnType(fn_decl) => {
                        if field.name == ctx.program_builder.string_interner.intern("env") {
                            let capture_struct_decl = todo!();
                            Ok(Type {
                                kind: TypeKind::Struct(capture_struct_decl),
                                span: expr_span,
                            })
                        } else {
                            Err(SemanticError {
                                kind: SemanticErrorKind::AccessToUndefinedStaticField(field),
                                span: field.span,
                            })
                        }
                    }
                    _ => Err(SemanticError {
                        span: left_span,
                        kind: SemanticErrorKind::CannotStaticAccess(left_type),
                    }),
                }
            }
            _ => Err(SemanticError {
                kind: SemanticErrorKind::ExpectedAType,
                span: expr_span,
            }),
        }
    }

    pub fn build_struct_init_expr(
        &mut self,
        ctx: &mut HIRContext,
        left: Box<Expr>,
        field_initializers: Vec<(IdentifierNode, Expr)>,
    ) -> Value {
        let type_expr_span = left.span;
        let left_type = match self.evaluate_expression_with_type_tail(ctx, *left) {
            Ok(t) => t,
            Err(e) => return Value::Use(self.report_error_and_get_poison(ctx, e)),
        };

        if let TypeKind::Struct(struct_decl) = &left_type.kind {
            let mut initialized_fields: HashSet<IdentifierNode> = HashSet::new();

            let struct_ptr = self.emit_stack_alloc(ctx, left_type.clone(), 1);

            for (field_name, field_expr) in field_initializers {
                if !initialized_fields.insert(field_name) {
                    return Value::Use(self.report_error_and_get_poison(
                        ctx,
                        SemanticError {
                            kind: SemanticErrorKind::DuplicateStructFieldInitializer(field_name),
                            span: field_name.span,
                        },
                    ));
                }

                let field_expr_span = field_expr.span;

                let field_ptr = match self.emit_get_field_ptr(ctx, struct_ptr, field_name) {
                    Ok(ptr) => ptr,
                    Err(error) => return Value::Use(self.report_error_and_get_poison(ctx, error)),
                };
                let field_ptr_type = ctx.program_builder.get_value_id_type(&field_ptr);

                let field_value = self.build_expr(ctx, field_expr);
                let field_value_type = ctx.program_builder.get_value_type(&field_value);

                if let TypeKind::Pointer(expected_field_type) = field_ptr_type.kind {
                    if !self.check_is_assignable(&field_value_type, &expected_field_type) {
                        return Value::Use(self.report_error_and_get_poison(
                            ctx,
                            SemanticError {
                                span: field_expr_span,
                                kind: SemanticErrorKind::TypeMismatch {
                                    expected: *expected_field_type,
                                    received: field_value_type,
                                },
                            },
                        ));
                    }
                } else {
                    panic!("INTERNAL COMPILER ERROR: struct field pointer must be a pointer");
                }

                self.emit_store(ctx, field_ptr, field_value);
            }

            let mut missing_initializers: HashSet<InternerId> = HashSet::new();
            for required_field in &struct_decl.fields {
                if !initialized_fields.contains(&required_field.identifier) {
                    missing_initializers.insert(required_field.identifier.name);
                }
            }
            if !missing_initializers.is_empty() {
                return Value::Use(self.report_error_and_get_poison(
                    ctx,
                    SemanticError {
                        kind: SemanticErrorKind::MissingStructFieldInitializers(missing_initializers),
                        span: type_expr_span,
                    },
                ));
            }

            let final_struct_value_id = self.emit_load(ctx, struct_ptr);
            return Value::Use(final_struct_value_id);
        } else {
            return Value::Use(self.report_error_and_get_poison(
                ctx,
                SemanticError {
                    span: type_expr_span,
                    kind: SemanticErrorKind::CannotApplyStructInitializer,
                },
            ));
        }
    }
}

```

`WillowLang/src/hir/expressions/typecast.rs`:

```rs
use crate::{
    ast::{expr::Expr, type_annotation::TypeAnnotation},
    hir::{cfg::Value, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_typecast_expr(&mut self, ctx: &mut HIRContext, left: Box<Expr>, target: TypeAnnotation) -> Value {
        let value = self.build_expr(ctx, *left);
        let target_type = self.check_type_annotation(ctx, &target);
        Value::Use(self.emit_type_cast(ctx, value, target_type))
    }
}

```

`WillowLang/src/hir/expressions/unary_op.rs`:

```rs
use crate::{
    ast::expr::Expr,
    hir::{
        cfg::{UnaryOperationKind, Value},
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_unary_op_expr(&mut self, ctx: &mut HIRContext, op_kind: UnaryOperationKind, expr: Box<Expr>) -> Value {
        let value = self.build_expr(ctx, *expr);
        let destination = match self.emit_unary_op(ctx, op_kind, value) {
            Ok(destination_id) => destination_id,
            Err(error) => {
                return Value::Use(self.report_error_and_get_poison(ctx, error));
            }
        };

        Value::Use(destination)
    }
}

```

`WillowLang/src/hir/mod.rs`:

```rs
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
    sync::atomic::{AtomicUsize, Ordering},
};

use crate::{
    ast::{stmt::Stmt, IdentifierNode},
    compile::string_interner::StringInterner,
    hir::{
        cfg::{
            BasicBlock, BasicBlockId, CheckedModule, ConstantId, ControlFlowGraph, FunctionId, HeapAllocationId, ModuleId,
            Terminator, Value, ValueId,
        },
        errors::SemanticError,
        types::{
            checked_declaration::CheckedParam,
            checked_type::{Type, TypeKind},
        },
        utils::scope::{Scope, ScopeKind},
    },
    tokenize::NumberKind,
};

pub mod cfg;
pub mod errors;
pub mod expressions;
pub mod statements;
pub mod types;
pub mod utils;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CapturedVar {
    pub original_value_id: ValueId,
    pub captured_as_field_ptr_id: ValueId,
    pub identifier: IdentifierNode,
}

pub struct HIRContext<'a, 'b> {
    // A mutable reference to the global program builder for services like ID generation.
    pub program_builder: &'b mut ProgramBuilder<'a>,
    // A mutable reference to the module builder for module-specific state.
    pub module_builder: &'b mut ModuleBuilder,
}

pub struct ProgramBuilder<'a> {
    pub modules: HashMap<ModuleId, ModuleBuilder>,
    pub value_types: HashMap<ValueId, Type>,
    pub string_interner: &'a mut StringInterner<'a>,
    /// Global errors
    pub errors: Vec<SemanticError>,

    value_id_counter: AtomicUsize,
    function_id_counter: AtomicUsize,
    constant_id_counter: AtomicUsize,
    allocation_id_counter: AtomicUsize,
}

#[derive(Debug)]
pub struct ModuleBuilder {
    pub module: CheckedModule,
    /// Module-specific errors
    pub errors: Vec<SemanticError>,
    /// Stack of closures
    pub functions: Vec<FunctionBuilder>,
    pub scopes: Vec<Scope>,
}

#[derive(Debug)]
pub struct FunctionBuilder {
    pub cfg: ControlFlowGraph,
    pub return_type: Type,
    pub captures: HashSet<CapturedVar>,

    pub current_block_id: BasicBlockId,
    block_id_counter: usize,
    value_id_counter: usize,
}

impl<'a> ProgramBuilder<'a> {
    pub fn new(string_interner: &'a mut StringInterner<'a>) -> Self {
        ProgramBuilder {
            errors: vec![],
            modules: HashMap::new(),
            value_types: HashMap::new(),
            string_interner,
            function_id_counter: AtomicUsize::new(0),
            constant_id_counter: AtomicUsize::new(0),
            allocation_id_counter: AtomicUsize::new(0),
            value_id_counter: AtomicUsize::new(0),
        }
    }

    pub fn build_module(&mut self, module_id: ModuleId, path: PathBuf, statements: Vec<Stmt>) {
        let mut module_builder = ModuleBuilder::new(module_id, path);
        module_builder.build_top_level_statements(self, statements);
        self.modules.insert(module_id, module_builder);
    }

    pub fn finish(self) -> (HashMap<ModuleId, ModuleBuilder>, Vec<SemanticError>) {
        let mut global_errors = vec![];

        // TODO: Check all imports were resolved.
        // TODO: Check for a single `main` function in the whole program.

        (self.modules, global_errors)
    }

    pub fn new_function_id(&self) -> FunctionId {
        FunctionId(self.function_id_counter.fetch_add(1, Ordering::SeqCst))
    }

    pub fn new_constant_id(&self) -> ConstantId {
        ConstantId(self.constant_id_counter.fetch_add(1, Ordering::SeqCst))
    }

    pub fn new_allocation_id(&self) -> HeapAllocationId {
        HeapAllocationId(self.allocation_id_counter.fetch_add(1, Ordering::SeqCst))
    }

    pub fn new_value_id(&self) -> ValueId {
        ValueId(self.value_id_counter.fetch_add(1, Ordering::SeqCst))
    }

    pub fn get_value_id_type(&self, value_id: &ValueId) -> Type {
        self.value_types
            .get(value_id)
            .expect("INTERNAL COMPILER ERROR: All ValueIds must have a corresponding type")
            .clone()
    }

    pub fn get_value_type(&self, value: &Value) -> Type {
        match value {
            Value::VoidLiteral => Type {
                kind: TypeKind::Void,
                span: Default::default(),
            },
            Value::BoolLiteral(_) => Type {
                kind: TypeKind::Bool,
                // TODO: fix this later
                span: Default::default(),
            },
            Value::NumberLiteral(kind) => {
                let kind = match kind {
                    NumberKind::I64(_) => TypeKind::I64,
                    NumberKind::I32(_) => TypeKind::I32,
                    NumberKind::I16(_) => TypeKind::I16,
                    NumberKind::I8(_) => TypeKind::I8,
                    NumberKind::F32(_) => TypeKind::F32,
                    NumberKind::F64(_) => TypeKind::F64,
                    NumberKind::U64(_) => TypeKind::U64,
                    NumberKind::U32(_) => TypeKind::U32,
                    NumberKind::U16(_) => TypeKind::U16,
                    NumberKind::U8(_) => TypeKind::U8,
                    NumberKind::USize(_) => TypeKind::USize,
                    NumberKind::ISize(_) => TypeKind::ISize,
                };

                Type {
                    kind,
                    span: Default::default(),
                }
            }
            Value::StringLiteral(_) => Type {
                kind: TypeKind::String,
                span: Default::default(),
            },
            Value::FunctionAddr { ty, .. } => ty.clone(),
            Value::Use(value_id) => self.get_value_id_type(value_id),
        }
    }
}

impl ModuleBuilder {
    pub fn new(id: ModuleId, path: PathBuf) -> Self {
        Self {
            module: CheckedModule::new(id, path),
            errors: vec![],
            functions: vec![],
            scopes: vec![Scope::new(ScopeKind::File)],
        }
    }

    fn build_top_level_statements(&mut self, program_builder: &mut ProgramBuilder, statements: Vec<Stmt>) {
        let mut ctx = HIRContext {
            module_builder: self,
            program_builder,
        };

        // TODO: One pass to add declarations to the scope (handle forward declarations)
        for stmt in &statements {
            todo!()
        }

        // TODO: Generate HIR
        for stmt in &statements {
            todo!()
        }

        todo!()
    }
}

impl FunctionBuilder {
    pub fn new(return_type: Type) -> Self {
        let entry_block_id = BasicBlockId(0);
        let cfg = ControlFlowGraph {
            blocks: HashMap::from([(
                entry_block_id,
                BasicBlock {
                    id: entry_block_id,
                    instructions: vec![],
                    terminator: Terminator::Unreachable,
                },
            )]),
            entry_block: entry_block_id,
        };

        Self {
            cfg,
            return_type,
            captures: HashSet::new(),
            current_block_id: entry_block_id,
            block_id_counter: 1,
            value_id_counter: 0,
        }
    }

    pub fn build_body(&mut self, ctx: &mut HIRContext, params: Vec<CheckedParam>, body: Vec<Stmt>) {
        for param in params {
            todo!()
        }

        for stmt in body {
            todo!()
        }
    }
}

```

`WillowLang/src/hir/statements/assignment.rs`:

```rs
use crate::{
    ast::expr::{Expr, ExprKind},
    hir::{
        cfg::ValueId,
        errors::{SemanticError, SemanticErrorKind},
        utils::scope::SymbolEntry,
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn build_lvalue_expr(&mut self, ctx: &mut HIRContext, expr: Expr) -> Result<ValueId, SemanticError> {
        match expr.kind {
            ExprKind::Identifier(identifier) => {
                if let Some(SymbolEntry::VarDecl(decl)) = ctx.module_builder.scope_lookup(identifier.name) {
                    return Ok(decl.value_id); // ValueId which holds Pointer<T>
                } else {
                    return Err(SemanticError {
                        kind: SemanticErrorKind::UndeclaredIdentifier(identifier),
                        span: expr.span,
                    });
                }
            }
            ExprKind::Access { left, field } => {
                let base_ptr_id = self.build_lvalue_expr(ctx, *left)?;
                Ok(self.emit_get_field_ptr(ctx, base_ptr_id, field)?)
            }
            _ => {
                return Err(SemanticError {
                    kind: SemanticErrorKind::InvalidLValue,
                    span: expr.span,
                });
            }
        }
    }

    pub fn build_assignment_stmt(&mut self, ctx: &mut HIRContext, target: Expr, value: Expr) {
        let source_val = self.build_expr(ctx, value);

        let destination_ptr = match self.build_lvalue_expr(ctx, target) {
            Ok(value_id) => value_id,
            Err(e) => {
                ctx.module_builder.errors.push(e);
                return;
            }
        };

        self.emit_store(ctx, destination_ptr, source_val);
    }
}

```

`WillowLang/src/hir/statements/enum_decl.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/statements/expression.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/statements/from.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/statements/mod.rs`:

```rs
pub mod assignment;
pub mod enum_decl;
pub mod expression;
pub mod from;
pub mod r#return;
pub mod type_alias_decl;
pub mod var_decl;
pub mod r#while;

use crate::{
    ast::{
        expr::ExprKind,
        stmt::{Stmt, StmtKind},
    },
    hir::{expressions::r#if::IfContext, FunctionBuilder, HIRContext},
};

impl FunctionBuilder {
    pub fn build_statements(&mut self, ctx: &mut HIRContext, statements: Vec<Stmt>) {
        for statement in statements {
            match statement.kind {
                StmtKind::Expression(expr) => {
                    if let ExprKind::If { branches, else_branch } = expr.kind {
                        self.build_if(ctx, branches, else_branch, IfContext::Statement);
                    } else {
                        self.build_expr(ctx, expr);
                    }
                }
                StmtKind::TypeAliasDecl(type_alias_decl) => todo!(),
                StmtKind::VarDecl(var_decl) => todo!(),
                StmtKind::Return { value } => todo!(),
                StmtKind::Assignment { target, value } => self.build_assignment_stmt(ctx, target, value),
                StmtKind::From { path, identifiers } => todo!(),
                StmtKind::While { condition, body } => todo!(),
                StmtKind::Break => todo!(),
                StmtKind::Continue => todo!(),
                StmtKind::StructDecl(struct_decl) => todo!(),
                StmtKind::EnumDecl(enum_decl) => todo!(),
            }
        }
    }
}

```

`WillowLang/src/hir/statements/return.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/statements/type_alias_decl.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/statements/var_decl.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/statements/while.rs`:

```rs
use crate::hir::FunctionBuilder;

impl FunctionBuilder {}

```

`WillowLang/src/hir/types/checked_declaration.rs`:

```rs
use std::hash::{Hash, Hasher};

use crate::{
    ast::{IdentifierNode, Span},
    hir::{cfg::ValueId, types::checked_type::Type},
    parse::DocAnnotation,
};

#[derive(Clone, Debug)]
pub struct CheckedParam {
    pub identifier: IdentifierNode,
    pub constraint: Type,
}

impl Eq for CheckedParam {}
impl PartialEq for CheckedParam {
    fn eq(&self, other: &Self) -> bool {
        self.identifier == other.identifier && self.constraint == other.constraint
    }
}
impl Hash for CheckedParam {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.identifier.hash(state);
        self.constraint.hash(state);
    }
}

#[derive(Clone, Debug)]
pub struct CheckedStructDecl {
    pub identifier: IdentifierNode,
    pub documentation: Option<DocAnnotation>,
    pub fields: Vec<CheckedParam>,
    pub span: Span,
}

impl Eq for CheckedStructDecl {}
impl PartialEq for CheckedStructDecl {
    fn eq(&self, other: &Self) -> bool {
        self.identifier == other.identifier
    }
}
impl Hash for CheckedStructDecl {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.identifier.hash(state);
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct CheckedEnumVariant {
    pub name: IdentifierNode,
    pub payload: Option<Type>,
}

#[derive(Clone, Debug)]
pub struct CheckedEnumDecl {
    pub identifier: IdentifierNode,
    pub documentation: Option<DocAnnotation>,
    pub variants: Vec<CheckedEnumVariant>,
}

impl Eq for CheckedEnumDecl {}
impl PartialEq for CheckedEnumDecl {
    fn eq(&self, other: &Self) -> bool {
        self.identifier == other.identifier
    }
}
impl Hash for CheckedEnumDecl {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.identifier.hash(state);
    }
}

#[derive(Clone, Debug)]
pub struct CheckedFnType {
    pub params: Vec<CheckedParam>,
    pub return_type: Box<Type>,
    pub span: Span,
}

impl Eq for CheckedFnType {}
impl PartialEq for CheckedFnType {
    fn eq(&self, other: &Self) -> bool {
        self.params == other.params && self.return_type == other.return_type
    }
}
impl Hash for CheckedFnType {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.params.hash(state);
        self.return_type.hash(state);
    }
}

#[derive(Clone, Debug)]
pub struct CheckedTypeAliasDecl {
    pub identifier: IdentifierNode,
    pub documentation: Option<DocAnnotation>,
    pub value: Box<Type>,
    pub span: Span,
}

impl Eq for CheckedTypeAliasDecl {}
impl PartialEq for CheckedTypeAliasDecl {
    fn eq(&self, other: &Self) -> bool {
        self.identifier == other.identifier
    }
}
impl Hash for CheckedTypeAliasDecl {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.identifier.hash(state);
    }
}

#[derive(Clone, Debug)]
pub struct CheckedVarDecl {
    pub value_id: ValueId,
    pub identifier: IdentifierNode,
    pub documentation: Option<DocAnnotation>,
    pub constraint: Type,
}

```

`WillowLang/src/hir/types/checked_type.rs`:

```rs
use std::hash::{Hash, Hasher};

use crate::{
    ast::{expr::BorrowKind, Span},
    hir::types::checked_declaration::{CheckedEnumDecl, CheckedFnType, CheckedStructDecl, CheckedTypeAliasDecl},
};

#[derive(Clone, Debug)]
pub enum TypeKind {
    Void,
    Bool,
    U8,
    U16,
    U32,
    U64,
    USize,
    ISize,
    I8,
    I16,
    I32,
    I64,
    F32,
    F64,
    String,
    Enum(CheckedEnumDecl),
    Struct(CheckedStructDecl),
    TypeAliasDecl(CheckedTypeAliasDecl),
    FnType(CheckedFnType),
    Borrow { kind: BorrowKind, value_type: Box<Type> },
    Pointer(Box<Type>),
    Unknown,
}

impl Eq for TypeKind {}
impl PartialEq for TypeKind {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (TypeKind::Void, TypeKind::Void) => true,
            (TypeKind::Bool, TypeKind::Bool) => true,
            (TypeKind::U8, TypeKind::U8) => true,
            (TypeKind::U16, TypeKind::U16) => true,
            (TypeKind::U32, TypeKind::U32) => true,
            (TypeKind::U64, TypeKind::U64) => true,
            (TypeKind::USize, TypeKind::USize) => true,
            (TypeKind::ISize, TypeKind::ISize) => true,
            (TypeKind::I8, TypeKind::I8) => true,
            (TypeKind::I16, TypeKind::I16) => true,
            (TypeKind::I32, TypeKind::I32) => true,
            (TypeKind::I64, TypeKind::I64) => true,
            (TypeKind::F32, TypeKind::F32) => true,
            (TypeKind::F64, TypeKind::F64) => true,
            (TypeKind::String, TypeKind::String) => true,
            (TypeKind::Unknown, TypeKind::Unknown) => true,
            (TypeKind::TypeAliasDecl(a), TypeKind::TypeAliasDecl(b)) => a == b,
            (TypeKind::Struct(a), TypeKind::Struct(b)) => a == b,
            (TypeKind::FnType(a), TypeKind::FnType(b)) => a == b,
            (TypeKind::Pointer(a), TypeKind::Pointer(b)) => a == b,
            (TypeKind::Enum(u1), TypeKind::Enum(u2)) => u1.identifier == u2.identifier,
            (
                TypeKind::Borrow {
                    kind: kind_a,
                    value_type: type_a,
                },
                TypeKind::Borrow {
                    kind: kind_b,
                    value_type: type_b,
                },
            ) => kind_a == kind_b && type_a.kind == type_b.kind,
            _ => false,
        }
    }
}

impl Hash for TypeKind {
    fn hash<H: Hasher>(&self, state: &mut H) {
        std::mem::discriminant(self).hash(state);

        match self {
            TypeKind::Void => {}
            TypeKind::Bool => {}
            TypeKind::U8 => {}
            TypeKind::U16 => {}
            TypeKind::U32 => {}
            TypeKind::U64 => {}
            TypeKind::USize => {}
            TypeKind::ISize => {}
            TypeKind::I8 => {}
            TypeKind::I16 => {}
            TypeKind::I32 => {}
            TypeKind::I64 => {}
            TypeKind::F32 => {}
            TypeKind::F64 => {}
            TypeKind::String => {}
            TypeKind::Unknown => {}
            TypeKind::Struct(decl) => decl.hash(state),
            TypeKind::TypeAliasDecl(decl) => decl.hash(state),
            TypeKind::FnType(decl) => decl.hash(state),
            TypeKind::Pointer(inner) => inner.hash(state),
            TypeKind::Enum(decl) => decl.hash(state),
            TypeKind::Borrow { kind, value_type } => {
                kind.hash(state);
                value_type.hash(state);
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct Type {
    pub kind: TypeKind,
    pub span: Span,
}

impl Eq for Type {}
impl PartialEq for Type {
    fn eq(&self, other: &Self) -> bool {
        self.kind == other.kind
    }
}
impl Hash for Type {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.kind.hash(state);
    }
}

```

`WillowLang/src/hir/types/mod.rs`:

```rs
pub mod checked_declaration;
pub mod checked_type;

```

`WillowLang/src/hir/utils/check_binary_numeric_op.rs`:

```rs
use crate::{
    ast::Span,
    hir::{
        errors::{SemanticError, SemanticErrorKind},
        types::checked_type::Type,
        utils::{get_numeric_type_rank::get_numeric_type_rank, is_float::is_float, is_integer::is_integer, is_signed::is_signed},
        FunctionBuilder,
    },
};

impl FunctionBuilder {
    pub fn check_binary_numeric_operation(&mut self, left: &Type, right: &Type) -> Result<Type, SemanticError> {
        let span = Span {
            start: left.span.start,
            end: right.span.end,
        };

        let left_type = if is_float(&left.kind) || is_integer(&left.kind) {
            left
        } else {
            return Err(SemanticError {
                kind: SemanticErrorKind::ExpectedANumericOperand,
                span: left.span,
            });
        };

        let right_type = if is_float(&right.kind) || is_integer(&right.kind) {
            right
        } else {
            return Err(SemanticError {
                kind: SemanticErrorKind::ExpectedANumericOperand,
                span: right.span,
            });
        };

        if (is_float(&left_type.kind) && is_integer(&right_type.kind))
            || (is_integer(&left_type.kind) && is_float(&right_type.kind))
        {
            return Err(SemanticError {
                kind: SemanticErrorKind::MixedFloatAndInteger,
                span,
            });
        }

        if is_signed(&left_type.kind) != is_signed(&right_type.kind) {
            return Err(SemanticError {
                kind: SemanticErrorKind::MixedSignedAndUnsigned,
                span,
            });
        }

        if right_type == left_type {
            return Ok(left_type.clone());
        }

        let left_rank = get_numeric_type_rank(&left_type.kind);
        let right_rank = get_numeric_type_rank(&right_type.kind);

        if left_rank > right_rank {
            Ok(Type {
                kind: left_type.kind.clone(),
                span,
            })
        } else {
            Ok(Type {
                kind: right_type.kind.clone(),
                span,
            })
        }
    }
}

```

`WillowLang/src/hir/utils/check_is_assignable.rs`:

```rs
use std::collections::HashSet;

use crate::hir::{
    types::{
        checked_declaration::CheckedFnType,
        checked_type::{Type, TypeKind},
    },
    FunctionBuilder,
};

impl FunctionBuilder {
    pub fn check_is_assignable(&self, source_type: &Type, target_type: &Type) -> bool {
        let mut visited_declarations: HashSet<(usize, usize)> = HashSet::new();
        self.check_is_assignable_recursive(source_type, target_type, &mut visited_declarations)
    }

    pub fn check_is_assignable_recursive(
        &self,
        source_type: &Type,
        target_type: &Type,
        visited_declarations: &mut HashSet<(usize, usize)>,
    ) -> bool {
        use TypeKind::*;
        // TODO: add recursion detection and handling

        let result = match (&source_type.kind, &target_type.kind) {
            (I8, I8)
            | (I16, I16)
            | (I32, I32)
            | (I64, I64)
            | (ISize, ISize)
            | (U8, U8)
            | (U16, U16)
            | (U32, U32)
            | (U64, U64)
            | (USize, USize)
            | (F32, F32)
            | (F64, F64)
            | (String, String)
            | (Bool, Bool)
            | (Void, Void)
            | (Unknown, _) => true,
            (Pointer(source), Pointer(target)) => self.check_is_assignable_recursive(source, target, visited_declarations),
            (Struct(source_decl), Struct(target_decl)) => {
                todo!()
            }
            (Enum(source_decl), Enum(target_decl)) => {
                todo!()
            }
            (
                FnType(CheckedFnType {
                    params: source_params,
                    return_type: source_return_type,
                    ..
                }),
                FnType(CheckedFnType {
                    params: target_params,
                    return_type: target_return_type,
                    ..
                }),
            ) => {
                if source_params.len() != target_params.len() {
                    return false;
                }

                let params_compatible = source_params
                    .iter()
                    .zip(target_params.iter())
                    .all(|(sp, tp)| self.check_is_assignable_recursive(&sp.constraint, &tp.constraint, visited_declarations));

                if !params_compatible {
                    return false;
                }

                let returns_compatible =
                    self.check_is_assignable_recursive(&source_return_type, &target_return_type, visited_declarations);

                returns_compatible
            }
            (TypeAliasDecl(source), _) => self.check_is_assignable_recursive(&source.value, target_type, visited_declarations),
            (_, TypeAliasDecl(target)) => self.check_is_assignable_recursive(source_type, &target.value, visited_declarations),
            _ => false,
        };

        result
    }
}

```

`WillowLang/src/hir/utils/check_is_casting_allowed.rs`:

```rs
use crate::hir::{
    types::checked_type::Type,
    utils::{get_numeric_type_rank::get_numeric_type_rank, is_float::is_float, is_integer::is_integer, is_signed::is_signed},
    FunctionBuilder,
};

impl FunctionBuilder {
    pub fn check_is_casting_allowed(&self, source_type: &Type, target_type: &Type) -> bool {
        match (&source_type.kind, &target_type.kind) {
            (st, tt) if is_integer(st) && is_integer(tt) && (is_signed(st) == is_signed(tt)) => {
                get_numeric_type_rank(st) <= get_numeric_type_rank(tt)
            }
            (st, tt) if is_float(st) && is_float(tt) => get_numeric_type_rank(st) <= get_numeric_type_rank(tt),
            (st, tt) if is_integer(st) && is_float(tt) => true,
            _ => false,
        }
    }
}

```

`WillowLang/src/hir/utils/check_is_equatable.rs`:

```rs
use crate::hir::types::checked_type::TypeKind;

use super::is_integer::is_integer;

pub fn check_is_equatable(left: &TypeKind, right: &TypeKind) -> bool {
    match (left, right) {
        (TypeKind::Bool, TypeKind::Bool) => true,
        (TypeKind::String, TypeKind::String) => true,
        (a, b) if is_integer(a) && is_integer(b) => true,
        // TODO: add other kinds
        _ => false,
    }
}

```

`WillowLang/src/hir/utils/check_type.rs`:

```rs
use crate::{
    ast::{
        decl::Param,
        type_annotation::{TypeAnnotation, TypeAnnotationKind},
        IdentifierNode, Span,
    },
    hir::{
        errors::{SemanticError, SemanticErrorKind},
        types::{
            checked_declaration::{CheckedFnType, CheckedParam},
            checked_type::{Type, TypeKind},
        },
        utils::scope::{ScopeKind, SymbolEntry},
        FunctionBuilder, HIRContext,
    },
};

impl FunctionBuilder {
    pub fn check_params(&mut self, ctx: &mut HIRContext, params: &Vec<Param>) -> Vec<CheckedParam> {
        params
            .into_iter()
            .map(|p| CheckedParam {
                constraint: self.check_type_annotation(ctx, &p.constraint),
                identifier: p.identifier,
            })
            .collect()
    }

    pub fn check_type_identifier_annotation(
        &mut self,
        ctx: &mut HIRContext,
        id: IdentifierNode,
        span: Span,
    ) -> Result<TypeKind, SemanticError> {
        ctx.module_builder
            .scope_lookup(id.name)
            .map(|entry| match entry {
                SymbolEntry::TypeAliasDecl(decl) => Ok(TypeKind::TypeAliasDecl(decl)),
                SymbolEntry::StructDecl(decl) => Ok(TypeKind::Struct(decl)),
                SymbolEntry::EnumDecl(decl) => Ok(TypeKind::Enum(decl)),
                SymbolEntry::VarDecl(_) => Err(SemanticError {
                    kind: SemanticErrorKind::CannotUseVariableDeclarationAsType,
                    span,
                }),
            })
            .unwrap_or_else(|| {
                Err(SemanticError {
                    kind: SemanticErrorKind::UndeclaredType(id),
                    span,
                })
            })
    }

    pub fn check_type_annotation(&mut self, ctx: &mut HIRContext, annotation: &TypeAnnotation) -> Type {
        let kind = match &annotation.kind {
            TypeAnnotationKind::Void => TypeKind::Void,
            TypeAnnotationKind::Bool => TypeKind::Bool,
            TypeAnnotationKind::U8 => TypeKind::U8,
            TypeAnnotationKind::U16 => TypeKind::U16,
            TypeAnnotationKind::U32 => TypeKind::U32,
            TypeAnnotationKind::U64 => TypeKind::U64,
            TypeAnnotationKind::USize => TypeKind::USize,
            TypeAnnotationKind::ISize => TypeKind::ISize,
            TypeAnnotationKind::I8 => TypeKind::I8,
            TypeAnnotationKind::I16 => TypeKind::I16,
            TypeAnnotationKind::I32 => TypeKind::I32,
            TypeAnnotationKind::I64 => TypeKind::I64,
            TypeAnnotationKind::F32 => TypeKind::F32,
            TypeAnnotationKind::F64 => TypeKind::F64,
            TypeAnnotationKind::String => TypeKind::String,
            TypeAnnotationKind::Identifier(id) => match self.check_type_identifier_annotation(ctx, *id, annotation.span) {
                Ok(t) => t,
                Err(error) => {
                    ctx.module_builder.errors.push(error);
                    TypeKind::Unknown
                }
            },
            TypeAnnotationKind::FnType { params, return_type } => {
                ctx.module_builder.enter_scope(ScopeKind::FnType);
                let checked_params = self.check_params(ctx, &params);
                let checked_return_type = self.check_type_annotation(ctx, return_type);
                ctx.module_builder.exit_scope();

                TypeKind::FnType(CheckedFnType {
                    params: checked_params,
                    return_type: Box::new(checked_return_type),
                    span: annotation.span,
                })
            }
            TypeAnnotationKind::Borrow { kind, value } => {
                let checked_value_type = self.check_type_annotation(ctx, &value);

                TypeKind::Borrow {
                    kind: *kind,
                    value_type: Box::new(checked_value_type),
                }
            }
        };

        Type {
            kind,
            span: annotation.span,
        }
    }
}

```

`WillowLang/src/hir/utils/get_numeric_type_rank.rs`:

```rs
use crate::hir::types::checked_type::TypeKind;

pub fn get_numeric_type_rank(ty: &TypeKind) -> i32 {
    use TypeKind::*;
    match &ty {
        I8 { .. } | U8 { .. } => 1,
        I16 { .. } | U16 { .. } => 2,
        I32 { .. } | U32 { .. } | ISize { .. } | USize { .. } => 3,
        I64 { .. } | U64 { .. } => 4,
        F32 { .. } => 5,
        F64 { .. } => 6,
        _ => 0,
    }
}

```

`WillowLang/src/hir/utils/instruction_emitters.rs`:

```rs
use std::collections::HashSet;

use crate::{
    ast::{IdentifierNode, Span},
    hir::{
        cfg::{BasicBlock, BasicBlockId, BinaryOperationKind, Instruction, PtrOffset, UnaryOperationKind, Value, ValueId},
        errors::{SemanticError, SemanticErrorKind},
        types::checked_type::{Type, TypeKind},
        utils::{check_is_equatable::check_is_equatable, is_signed::is_signed},
        FunctionBuilder, HIRContext, ModuleBuilder,
    },
};

impl FunctionBuilder {
    /// Records a semantic error and returns a new "poison" Value of type Unknown.
    /// The caller is responsible for immediately returning the poison Value.
    pub fn report_error_and_get_poison(&mut self, ctx: &mut HIRContext, error: SemanticError) -> ValueId {
        let error_span = error.span;
        ctx.module_builder.errors.push(error);
        let unknown_result_id = ctx.program_builder.new_value_id();
        ctx.program_builder.value_types.insert(
            unknown_result_id,
            Type {
                kind: TypeKind::Unknown,
                span: error_span,
            },
        );
        unknown_result_id
    }

    pub fn get_current_basic_block(&mut self) -> &mut BasicBlock {
        self.cfg.blocks.get_mut(&self.current_block_id).unwrap_or_else(|| {
            panic!(
                "INTERNAL COMPILER ERROR: Basic block with id '{}' does not exist.",
                self.current_block_id.0
            )
        })
    }

    /// Returns ValueId which holds pointer: TypeKind::Pointer(Box<Type>)
    pub fn emit_stack_alloc(&mut self, ctx: &mut HIRContext, ty: Type, count: usize) -> ValueId {
        let destination = ctx.program_builder.new_value_id();

        ctx.program_builder.value_types.insert(
            destination,
            Type {
                span: ty.span,
                kind: TypeKind::Pointer(Box::new(ty)),
            },
        );

        self.get_current_basic_block()
            .instructions
            .push(Instruction::StackAlloc { destination, count });

        destination
    }

    /// Returns ValueId which holds pointer: TypeKind::Pointer(Box<Type>)
    pub fn emit_heap_alloc(&mut self, ctx: &mut HIRContext, ty: Type, count: Value) -> Result<ValueId, SemanticError> {
        let count_type = ctx.program_builder.get_value_type(&count);
        let expected_count_type = Type {
            kind: TypeKind::USize,
            span: count_type.span,
        };
        if !self.check_is_assignable(&count_type, &expected_count_type) {
            return Err(SemanticError {
                span: count_type.span,
                kind: SemanticErrorKind::TypeMismatch {
                    expected: Type {
                        kind: TypeKind::USize,
                        span: count_type.span,
                    },
                    received: count_type,
                },
            });
        }

        let destination = ctx.program_builder.new_value_id();
        let allocation_site_id = ctx.program_builder.new_allocation_id();

        ctx.program_builder.value_types.insert(
            destination,
            Type {
                span: ty.span,
                kind: TypeKind::Pointer(Box::new(ty)),
            },
        );

        self.get_current_basic_block().instructions.push(Instruction::HeapAlloc {
            destination,
            allocation_site_id,
            count,
        });

        Ok(destination)
    }

    pub fn emit_store(&mut self, ctx: &mut HIRContext, destination_ptr: ValueId, value: Value) {
        let value_type = ctx.program_builder.get_value_type(&value);
        let destination_ptr_type = ctx.program_builder.get_value_id_type(&destination_ptr);

        if let TypeKind::Pointer(target_type) = destination_ptr_type.kind {
            if !self.check_is_assignable(&value_type, &target_type) {
                ctx.module_builder.errors.push(SemanticError {
                    span: value_type.span,
                    kind: SemanticErrorKind::TypeMismatch {
                        expected: *target_type,
                        received: value_type,
                    },
                });
                return;
            }
        } else {
            panic!("INTERNAL COMPILER ERROR: Expected destination_ptr_id to be of Pointer<T> type");
        }

        self.get_current_basic_block().instructions.push(Instruction::Store {
            destination_ptr,
            source_val: value,
        });
    }

    pub fn emit_load(&mut self, ctx: &mut HIRContext, source_ptr: ValueId) -> ValueId {
        let ptr_type = ctx.program_builder.get_value_id_type(&source_ptr);

        let destination_type = if let TypeKind::Pointer(t) = ptr_type.kind {
            *t
        } else {
            panic!("INTERNAL COMPILER ERROR: Expected source_ptr to be of Pointer<T> type");
        };

        let destination = ctx.program_builder.new_value_id();

        ctx.program_builder.value_types.insert(destination, destination_type);

        self.get_current_basic_block()
            .instructions
            .push(Instruction::Load { destination, source_ptr });

        destination
    }

    pub fn emit_get_field_ptr(
        &mut self,
        ctx: &mut HIRContext,
        base_ptr: ValueId,
        field: IdentifierNode,
    ) -> Result<ValueId, SemanticError> {
        let base_ptr_type = ctx.program_builder.get_value_id_type(&base_ptr);

        let struct_decl = if let TypeKind::Pointer(ptr_to) = &base_ptr_type.kind {
            if let TypeKind::Struct(s) = &ptr_to.kind {
                s
            } else {
                return Err(SemanticError {
                    kind: SemanticErrorKind::CannotAccess(ptr_to.as_ref().clone()),
                    span: field.span,
                });
            }
        } else {
            panic!("INTERNAL COMPILER ERROR: emit_get_field_ptr called on a non-pointer type.");
        };

        if let Some((field_index, checked_field)) = struct_decl
            .fields
            .iter()
            .enumerate()
            .find(|(_, f)| f.identifier.name == field.name)
        {
            let destination = ctx.program_builder.new_value_id();
            let field_type = &checked_field.constraint;

            ctx.program_builder.value_types.insert(
                destination,
                Type {
                    kind: TypeKind::Pointer(Box::new(field_type.clone())),
                    span: field.span,
                },
            );

            self.get_current_basic_block().instructions.push(Instruction::GetFieldPtr {
                destination,
                base_ptr,
                field_index,
            });

            Ok(destination)
        } else {
            Err(SemanticError {
                kind: SemanticErrorKind::AccessToUndefinedField(field),
                span: field.span,
            })
        }
    }

    pub fn emit_ptr_add(&mut self, ctx: &mut HIRContext, base_ptr: ValueId, offset: PtrOffset) -> Result<ValueId, SemanticError> {
        let base_ptr_type = ctx.program_builder.get_value_id_type(&base_ptr);
        if !matches!(base_ptr_type.kind, TypeKind::Pointer(_)) {
            panic!("INTERNAL COMPILER ERROR: emit_ptr_add called on a non-pointer type.");
        }

        if let PtrOffset::Dynamic(value) = &offset {
            let index_type = ctx.program_builder.get_value_type(value);
            let expected_index_type = Type {
                kind: TypeKind::USize,
                span: index_type.span,
            };
            if !self.check_is_assignable(&index_type, &expected_index_type) {
                return Err(SemanticError {
                    span: index_type.span,
                    kind: SemanticErrorKind::TypeMismatch {
                        expected: expected_index_type,
                        received: index_type,
                    },
                });
            }
        }

        let destination = ctx.program_builder.new_value_id();

        ctx.program_builder.value_types.insert(destination, base_ptr_type);
        self.get_current_basic_block().instructions.push(Instruction::PtrAdd {
            destination,
            base_ptr,
            offset,
        });

        Ok(destination)
    }

    pub fn emit_unary_op(
        &mut self,
        ctx: &mut HIRContext,
        op_kind: UnaryOperationKind,
        value: Value,
    ) -> Result<ValueId, SemanticError> {
        let value_type = ctx.program_builder.get_value_type(&value);
        let span = value_type.span;

        let destination = match op_kind {
            UnaryOperationKind::Neg => {
                if !is_signed(&value_type.kind) {
                    let expected = HashSet::from([
                        Type {
                            kind: TypeKind::I8,
                            span,
                        },
                        Type {
                            kind: TypeKind::I16,
                            span,
                        },
                        Type {
                            kind: TypeKind::I32,
                            span,
                        },
                        Type {
                            kind: TypeKind::I64,
                            span,
                        },
                        Type {
                            kind: TypeKind::ISize,
                            span,
                        },
                        Type {
                            kind: TypeKind::F32,
                            span,
                        },
                        Type {
                            kind: TypeKind::F64,
                            span,
                        },
                    ]);

                    return Err(SemanticError {
                        kind: SemanticErrorKind::TypeMismatchExpectedOneOf {
                            expected,
                            received: value_type.clone(),
                        },
                        span,
                    });
                }

                ctx.program_builder.new_value_id()
            }
            UnaryOperationKind::Not => {
                let bool_type = Type {
                    kind: TypeKind::Bool,
                    span,
                };

                if !self.check_is_assignable(&value_type, &bool_type) {
                    return Err(SemanticError {
                        kind: SemanticErrorKind::TypeMismatch {
                            expected: bool_type.clone(),
                            received: value_type,
                        },
                        span,
                    });
                }

                ctx.program_builder.new_value_id()
            }
        };

        ctx.program_builder.value_types.insert(destination, value_type);
        self.get_current_basic_block().instructions.push(Instruction::UnaryOp {
            op_kind,
            destination,
            operand: value,
        });

        Ok(destination)
    }

    pub fn emit_binary_op(
        &mut self,
        ctx: &mut HIRContext,
        op_kind: BinaryOperationKind,
        left: Value,
        right: Value,
    ) -> Result<ValueId, SemanticError> {
        let left_type = ctx.program_builder.get_value_type(&left);
        let right_type = ctx.program_builder.get_value_type(&right);
        let combined_span = Span {
            start: left_type.span.start,
            end: right_type.span.end,
        };

        let destination_type = match op_kind {
            BinaryOperationKind::Add
            | BinaryOperationKind::Subtract
            | BinaryOperationKind::Multiply
            | BinaryOperationKind::Divide
            | BinaryOperationKind::Modulo => {
                let result_type = self.check_binary_numeric_operation(&left_type, &right_type)?;
                result_type
            }

            BinaryOperationKind::LessThan
            | BinaryOperationKind::LessThanOrEqual
            | BinaryOperationKind::GreaterThan
            | BinaryOperationKind::GreaterThanOrEqual => {
                self.check_binary_numeric_operation(&left_type, &right_type)?;

                Type {
                    kind: TypeKind::Bool,
                    span: combined_span,
                }
            }

            BinaryOperationKind::Equal | BinaryOperationKind::NotEqual => {
                if !check_is_equatable(&left_type.kind, &right_type.kind) {
                    return Err(SemanticError {
                        span: Span {
                            start: left_type.span.start,
                            end: right_type.span.end,
                        },
                        kind: SemanticErrorKind::CannotCompareType {
                            of: left_type,
                            to: right_type,
                        },
                    });
                }

                Type {
                    kind: TypeKind::Bool,
                    span: combined_span,
                }
            }
        };

        let destination = ctx.program_builder.new_value_id();
        ctx.program_builder.value_types.insert(destination, destination_type);
        self.get_current_basic_block().instructions.push(Instruction::BinaryOp {
            op_kind,
            destination,
            left,
            right,
        });

        Ok(destination)
    }

    pub fn emit_phi(&mut self, ctx: &mut HIRContext, sources: Vec<(BasicBlockId, Value)>) -> Result<ValueId, SemanticError> {
        if sources.is_empty() {
            panic!("INTERNAL COMPILER ERROR: emit_phi called with no sources.");
        }

        let first_type = ctx.program_builder.get_value_type(&sources[0].1);

        for (_, other_value) in sources.iter().skip(1) {
            let other_type = ctx.program_builder.get_value_type(other_value);
            if !self.check_is_assignable(&other_type, &first_type) {
                return Err(SemanticError {
                    span: other_type.span,
                    kind: SemanticErrorKind::IncompatibleBranchTypes {
                        first: first_type,
                        second: other_type,
                    },
                });
            }
        }

        let destination = ctx.program_builder.new_value_id();
        ctx.program_builder.value_types.insert(destination, first_type);
        self.get_current_basic_block()
            .instructions
            .push(Instruction::Phi { destination, sources });

        Ok(destination)
    }

    pub fn emit_function_call(
        &mut self,
        ctx: &mut HIRContext,
        value: Value,
        args: Vec<Value>,
        call_span: Span,
    ) -> Result<Option<ValueId>, SemanticError> {
        let value_type = ctx.program_builder.get_value_type(&value);

        let fn_type_decl = if let TypeKind::FnType(decl) = value_type.kind {
            decl
        } else {
            return Err(SemanticError {
                kind: SemanticErrorKind::CannotCall(value_type),
                span: call_span,
            });
        };

        if args.len() != fn_type_decl.params.len() {
            return Err(SemanticError {
                kind: SemanticErrorKind::FnArgumentCountMismatch {
                    expected: fn_type_decl.params.len(),
                    received: args.len(),
                },
                span: call_span,
            });
        }

        for (arg_value, param_decl) in args.iter().zip(fn_type_decl.params.iter()) {
            let arg_type = ctx.program_builder.get_value_type(arg_value);
            let param_type = &param_decl.constraint;

            if !self.check_is_assignable(&arg_type, param_type) {
                return Err(SemanticError {
                    span: arg_type.span,
                    kind: SemanticErrorKind::TypeMismatch {
                        expected: param_type.clone(),
                        received: arg_type,
                    },
                });
            }
        }

        let destination_id = if fn_type_decl.return_type.kind != TypeKind::Void {
            let dest_id = ctx.program_builder.new_value_id();
            ctx.program_builder.value_types.insert(dest_id, *fn_type_decl.return_type);
            Some(dest_id)
        } else {
            None
        };

        self.get_current_basic_block().instructions.push(Instruction::FunctionCall {
            destination: destination_id,
            function_rvalue: value,
            args,
        });

        Ok(destination_id)
    }

    pub fn emit_type_cast(&mut self, ctx: &mut HIRContext, value: Value, target_type: Type) -> ValueId {
        let value_type = ctx.program_builder.get_value_type(&value);

        if !self.check_is_casting_allowed(&value_type, &target_type) {
            return self.report_error_and_get_poison(
                ctx,
                SemanticError {
                    span: value_type.span,
                    kind: SemanticErrorKind::CannotCastType {
                        source_type: value_type.clone(),
                        target_type: target_type.clone(),
                    },
                },
            );
        }

        let destination = ctx.program_builder.new_value_id();
        ctx.program_builder.value_types.insert(destination, target_type.clone());

        self.get_current_basic_block().instructions.push(Instruction::TypeCast {
            destination,
            operand: value,
            target_type,
        });

        destination
    }

    pub fn emit_nop(&mut self, module_builder: &mut ModuleBuilder) {
        todo!()
    }
}

```

`WillowLang/src/hir/utils/is_float.rs`:

```rs
use crate::hir::types::checked_type::TypeKind;

pub fn is_float(ty: &TypeKind) -> bool {
    use TypeKind::*;
    matches!(ty, F32 | F64)
}

```

`WillowLang/src/hir/utils/is_integer.rs`:

```rs
use crate::hir::types::checked_type::TypeKind;

pub fn is_integer(ty: &TypeKind) -> bool {
    use TypeKind::*;
    matches!(ty, I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | ISize | USize)
}

```

`WillowLang/src/hir/utils/is_signed.rs`:

```rs
use crate::hir::types::checked_type::TypeKind;

pub fn is_signed(ty: &TypeKind) -> bool {
    use TypeKind::*;
    matches!(ty, I8 | I16 | I32 | I64 | ISize | F32 | F64)
}

```

`WillowLang/src/hir/utils/mod.rs`:

```rs
pub mod check_binary_numeric_op;
pub mod check_is_assignable;
pub mod check_is_casting_allowed;
pub mod check_is_equatable;
pub mod check_type;
pub mod get_numeric_type_rank;
pub mod instruction_emitters;
pub mod is_float;
pub mod is_integer;
pub mod is_signed;
pub mod new_basic_block;
pub mod scope;
pub mod set_basic_block_terminator;
pub mod type_to_string;
pub mod use_basic_block;

```

`WillowLang/src/hir/utils/new_basic_block.rs`:

```rs
use crate::hir::{
    cfg::{BasicBlock, BasicBlockId, Terminator},
    FunctionBuilder,
};

impl FunctionBuilder {
    pub fn new_basic_block(&mut self) -> BasicBlockId {
        let block_id = BasicBlockId(self.block_id_counter);
        self.block_id_counter += 1;
        self.cfg.blocks.insert(
            block_id,
            BasicBlock {
                id: block_id,
                instructions: vec![],
                terminator: Terminator::Unreachable,
            },
        );

        block_id
    }
}

```

`WillowLang/src/hir/utils/scope.rs`:

```rs
use std::collections::HashMap;

use crate::{
    ast::{IdentifierNode, Span},
    compile::string_interner::InternerId,
    hir::{
        cfg::BasicBlockId,
        errors::{SemanticError, SemanticErrorKind},
        types::checked_declaration::{CheckedEnumDecl, CheckedStructDecl, CheckedTypeAliasDecl, CheckedVarDecl},
        ModuleBuilder,
    },
};

#[derive(Debug, Clone, PartialEq)]
pub enum ScopeKind {
    Function,
    While {
        break_target: BasicBlockId,
        continue_target: BasicBlockId,
    },
    CodeBlock,
    File,
    TypeAlias,
    FnType,
}

#[derive(Debug, Clone)]
pub enum SymbolEntry {
    VarDecl(CheckedVarDecl),
    TypeAliasDecl(CheckedTypeAliasDecl),
    StructDecl(CheckedStructDecl),
    EnumDecl(CheckedEnumDecl),
}

#[derive(Debug)]
pub struct Scope {
    pub kind: ScopeKind,
    symbols: HashMap<InternerId, SymbolEntry>,
}

impl Scope {
    pub fn new(kind: ScopeKind) -> Scope {
        Scope {
            symbols: HashMap::new(),
            kind,
        }
    }
}

impl ModuleBuilder {
    pub fn enter_scope(&mut self, kind: ScopeKind) {
        self.scopes.push(Scope::new(kind));
    }

    pub fn exit_scope(&mut self) -> Scope {
        self.scopes
            .pop()
            .expect("INTERNAL COMPILER ERROR: Expected to be able to pop the last scope")
    }

    pub fn last_scope(&self) -> &Scope {
        self.scopes
            .last()
            .expect("INTERNAL COMPILER ERROR: Expected to find the last scope")
    }

    pub fn last_scope_mut(&mut self) -> &mut Scope {
        self.scopes
            .last_mut()
            .expect("INTERNAL COMPILER ERROR: Expected to find the last mutable scope")
    }

    pub fn scope_insert(&mut self, id: IdentifierNode, value: SymbolEntry, span: Span) {
        let last_scope = self.last_scope_mut();

        if let Some(_) = last_scope.symbols.insert(id.name, value) {
            self.errors.push(SemanticError {
                kind: SemanticErrorKind::DuplicateIdentifier(id),
                span,
            });
        }
    }

    pub fn scope_lookup(&self, key: InternerId) -> Option<SymbolEntry> {
        for scope in self.scopes.iter().rev() {
            if let Some(declaration) = scope.symbols.get(&key) {
                let cloned = declaration.to_owned();
                return Some(cloned);
            }
        }

        None
    }

    pub fn within_function_scope(&self) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.kind == ScopeKind::Function {
                return true;
            }
        }

        return false;
    }

    pub fn within_loop_scope(&self) -> Option<(BasicBlockId, BasicBlockId)> {
        for scope in self.scopes.iter().rev() {
            match scope.kind {
                ScopeKind::CodeBlock => {}
                ScopeKind::While {
                    continue_target,
                    break_target,
                } => return Some((continue_target, break_target)),
                _ => return None,
            }
        }

        None
    }

    pub fn is_file_scope(&self) -> bool {
        self.last_scope().kind == ScopeKind::File
    }
}

```

`WillowLang/src/hir/utils/set_basic_block_terminator.rs`:

```rs
use crate::hir::{cfg::Terminator, FunctionBuilder};

impl FunctionBuilder {
    pub fn set_basic_block_terminator(&mut self, terminator: Terminator) {
        let current_basic_block = self.cfg.blocks.get_mut(&self.current_block_id);

        if let Some(bb) = current_basic_block {
            bb.terminator = terminator;
        } else {
            panic!(
                "INTERNAL COMPILER ERROR: Could not set basic block terminator: basic block with id: {} doesn't exist.",
                self.current_block_id.0
            );
        }
    }
}

```

`WillowLang/src/hir/utils/type_to_string.rs`:

```rs
use std::collections::HashSet;

use crate::{
    ast::expr::BorrowKind,
    compile::string_interner::{InternerId, StringInterner},
    hir::types::{checked_declaration::CheckedFnType, checked_type::TypeKind},
};

fn identifier_to_string(id: InternerId, string_interner: &StringInterner) -> String {
    let identifier_name = string_interner.resolve(id);

    identifier_name.to_owned()
}

pub fn type_to_string(ty: &TypeKind, string_interner: &StringInterner) -> String {
    let mut visited_set = HashSet::new();
    type_to_string_recursive(ty, string_interner, &mut visited_set)
}

pub fn type_to_string_recursive(ty: &TypeKind, string_interner: &StringInterner, visited_set: &mut HashSet<TypeKind>) -> String {
    // TODO: add recursion detection and handling

    match ty {
        TypeKind::Void => String::from("void"),
        TypeKind::Bool => String::from("bool"),
        TypeKind::U8 => String::from("u8"),
        TypeKind::U16 => String::from("u16"),
        TypeKind::U32 => String::from("u32"),
        TypeKind::U64 => String::from("u64"),
        TypeKind::USize => String::from("usize"),
        TypeKind::ISize => String::from("isize"),
        TypeKind::I8 => String::from("i8"),
        TypeKind::I16 => String::from("i16"),
        TypeKind::I32 => String::from("i32"),
        TypeKind::I64 => String::from("i64"),
        TypeKind::F32 => String::from("f32"),
        TypeKind::F64 => String::from("f64"),
        TypeKind::String => String::from("string"),
        TypeKind::Unknown => String::from("unknown"),
        TypeKind::Struct(decl) => {
            let name = identifier_to_string(decl.identifier.name, string_interner);
            let fields = decl
                .fields
                .iter()
                .map(|p| {
                    format!(
                        "{}: {}",
                        identifier_to_string(p.identifier.name, string_interner),
                        type_to_string_recursive(&p.constraint.kind, string_interner, visited_set)
                    )
                })
                .collect::<Vec<String>>()
                .join(",\n");

            format!("struct {} {{\n{}\n}}", name, fields)
        }
        TypeKind::FnType(CheckedFnType {
            params,
            return_type,
            span: _,
        }) => {
            let params_str = params
                .iter()
                .map(|p| {
                    format!(
                        "{}: {}",
                        identifier_to_string(p.identifier.name, string_interner),
                        type_to_string_recursive(&p.constraint.kind, string_interner, visited_set)
                    )
                })
                .collect::<Vec<String>>()
                .join(", ");

            let return_type_str = type_to_string_recursive(&return_type.kind, string_interner, visited_set);
            let fn_str = format!("fn ({}): {}", params_str, return_type_str);

            fn_str
        }
        TypeKind::TypeAliasDecl(decl) => {
            let name = identifier_to_string(decl.identifier.name, string_interner);

            let value = type_to_string_recursive(&decl.value.kind, string_interner, visited_set);

            format!("type {} = {};", name, value)
        }
        TypeKind::Pointer(ty) => format!("ptr<{}>", type_to_string_recursive(&ty.kind, string_interner, visited_set)),
        TypeKind::Enum(decl) => {
            let variants = decl
                .variants
                .iter()
                .map(|v| match &v.payload {
                    Some(pt) => {
                        format!(
                            "{}({})",
                            identifier_to_string(v.name.name, string_interner),
                            type_to_string(&pt.kind, string_interner)
                        )
                    }
                    None => {
                        format!("{}", identifier_to_string(v.name.name, string_interner))
                    }
                })
                .collect::<Vec<String>>()
                .join(",\n");

            format!(
                "enum {} {{\n{}\n}}",
                identifier_to_string(decl.identifier.name, string_interner),
                variants
            )
        }
        TypeKind::Borrow { kind, value_type } => {
            let prefix = match kind {
                BorrowKind::Shared => "&".to_string(),
                BorrowKind::Mutable => "&mut".to_string(),
            };

            format!(
                "{} {}",
                prefix,
                type_to_string_recursive(&value_type.kind, string_interner, visited_set)
            )
        }
    }
}

```

`WillowLang/src/hir/utils/use_basic_block.rs`:

```rs
use crate::hir::{cfg::BasicBlockId, FunctionBuilder};

impl FunctionBuilder {
    pub fn use_basic_block(&mut self, id: BasicBlockId) {
        if let Some(_) = self.cfg.blocks.get(&id) {
            self.current_block_id = id;
        } else {
            panic!(
                "INTERNAL COMPILER ERROR: Could not use basic block with id {} as it doesn't exist",
                id.0
            );
        }
    }
}

```

`WillowLang/src/lib.rs`:

```rs
pub mod ast;
pub mod codegen;
pub mod compile;
pub mod hir;
pub mod parse;
pub mod tokenize;

```

`WillowLang/src/main.rs`:

```rs
use std::fs;

use codespan_reporting::files::SimpleFiles;
use willow::compile::{compile_file, string_interner::StringInterner};

fn main() {
    let file_path = match std::env::args().nth(1) {
        Some(path) => path,
        None => {
            eprintln!("{}", "\nExpected file path to the program entry\n");
            return;
        }
    };

    let source_code = match fs::read_to_string(&file_path) {
        Ok(source) => source,
        Err(_) => {
            eprintln!("\n{}{}\n", "Could not read file at path:\n", file_path);
            return;
        }
    };

    let mut string_interner = StringInterner::new();
    let mut files = SimpleFiles::new();

    compile_file(&file_path, &source_code, &mut string_interner, &mut files);

    // let mut coll = string_interner.forward.into_iter().collect::<Vec<_>>();
    // coll.sort_by(|a, b| a.1.cmp(&b.1));
    // coll.iter().for_each(|(name, id)| println!("{}: {}", id, name));
}

```

`WillowLang/src/parse/expressions/mod.rs`:

```rs
pub mod parse_codeblock_expr;
pub mod parse_enum_init_expr;
pub mod parse_fn_call_expr;
pub mod parse_fn_expr;
pub mod parse_if_expr;
pub mod parse_list_literal_expr;
pub mod parse_match_expr;
pub mod parse_parenthesized_expr;
pub mod parse_struct_init_expr;

use crate::{
    ast::{
        expr::{BorrowKind, Expr, ExprKind},
        Span,
    },
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

use super::{Parser, ParsingError, ParsingErrorKind};

fn prefix_bp(token_kind: &TokenKind) -> Option<((), u8)> {
    use PunctuationKind::*;
    use TokenKind::*;

    let priority = match token_kind {
        Punctuation(Minus) | Punctuation(Not) | Punctuation(And) => ((), 13),
        _ => return None,
    };

    Some(priority)
}

fn infix_bp(token_kind: &TokenKind) -> Option<(u8, u8)> {
    use PunctuationKind::*;
    use TokenKind::*;

    let priority = match token_kind {
        Punctuation(DoubleOr) => (1, 2),
        Punctuation(DoubleAnd) => (3, 4),
        Punctuation(DoubleEq) | Punctuation(NotEq) => (5, 6),
        Punctuation(Lt) | Punctuation(Lte) | Punctuation(Gt) | Punctuation(Gte) => (7, 8),
        Punctuation(Plus) | Punctuation(Minus) => (9, 10),
        Punctuation(Star) | Punctuation(Slash) | Punctuation(Percent) => (11, 12),
        _ => return None,
    };

    Some(priority)
}

fn suffix_bp(token_kind: &TokenKind) -> Option<(u8, ())> {
    use PunctuationKind::*;
    use TokenKind::*;

    let priority = match token_kind {
        Punctuation(LParen) | Punctuation(LBrace) => (14, ()), // fn call and struct init
        Punctuation(Dot) | Punctuation(DoubleCol) => (14, ()), // member/static accesses
        _ => return None,
    };

    Some(priority)
}

pub fn is_start_of_expr(token_kind: &TokenKind) -> bool {
    match token_kind {
        TokenKind::Identifier(_)
        | TokenKind::Number(_)
        | TokenKind::String(_)
        | TokenKind::Keyword(KeywordKind::Fn)
        | TokenKind::Keyword(KeywordKind::True)
        | TokenKind::Keyword(KeywordKind::False)
        | TokenKind::Keyword(KeywordKind::If)
        | TokenKind::Keyword(KeywordKind::Match)
        | TokenKind::Punctuation(PunctuationKind::LParen)   // Parenthesized expr
        | TokenKind::Punctuation(PunctuationKind::LBrace)   // Codeblock expr
        | TokenKind::Punctuation(PunctuationKind::LBracket) // List literal
        | TokenKind::Punctuation(PunctuationKind::Minus)    // Negation
        | TokenKind::Punctuation(PunctuationKind::Not)      // Logical NOT
        => true,
        _ => false,
    }
}

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_expr(&mut self, min_prec: u8) -> Result<Expr, ParsingError<'a>> {
        let token = self.current().ok_or(self.unexpected_end_of_input())?;

        let token_span = token.span;

        let mut lhs = match token.kind {
            TokenKind::Identifier(_) => {
                let identifier = self.consume_identifier()?;
                Expr {
                    kind: ExprKind::Identifier(identifier),
                    span: token_span,
                }
            }
            TokenKind::Number(_) => {
                let number = self.consume_number()?;
                Expr {
                    kind: ExprKind::Number(number),
                    span: token_span,
                }
            }
            TokenKind::Punctuation(PunctuationKind::And) => {
                let ((), r_bp) = prefix_bp(&TokenKind::Punctuation(PunctuationKind::And)).expect(
                    "INTERNAL COMPILER ERROR: expected the minus \'-\' symbol to have a corresponding prefix binding power",
                );
                let start_offset = self.offset;

                self.advance();
                let kind = if self.match_token(0, TokenKind::Keyword(KeywordKind::Mut)) {
                    self.advance();
                    BorrowKind::Mutable
                } else {
                    BorrowKind::Shared
                };

                let value = Box::new(self.parse_expr(r_bp)?);

                Expr {
                    kind: ExprKind::Borrow { kind, value },
                    span: self.get_span(start_offset, self.offset - 1)?,
                }
            }
            TokenKind::Keyword(KeywordKind::Match) => self.parse_match_expr()?,
            TokenKind::Keyword(KeywordKind::Fn) => self.parse_fn_expr()?,
            TokenKind::Punctuation(PunctuationKind::LParen) => {
                let start_offset = self.offset;
                let result = self.parse_parenthesized_expr()?;
                let span = self.get_span(start_offset, self.offset - 1)?;

                Expr { kind: result.kind, span }
            }
            TokenKind::Punctuation(PunctuationKind::LBrace) => {
                let block_contents = self.parse_codeblock_expr()?;

                Expr {
                    span: block_contents.span,
                    kind: ExprKind::CodeBlock(block_contents),
                }
            }
            TokenKind::Punctuation(PunctuationKind::LBracket) => self.parse_list_literal_expr()?,
            TokenKind::Punctuation(PunctuationKind::Minus) => {
                let ((), r_bp) = prefix_bp(&TokenKind::Punctuation(PunctuationKind::Minus)).expect(
                    "INTERNAL COMPILER ERROR: expected the minus \'-\' symbol to have a corresponding prefix binding power",
                );
                let start_offset = self.offset;

                self.consume_punctuation(PunctuationKind::Minus)?;
                let expr = self.parse_expr(r_bp)?;
                Expr {
                    kind: ExprKind::Neg { right: Box::new(expr) },
                    span: self.get_span(start_offset, self.offset - 1)?,
                }
            }
            TokenKind::Punctuation(PunctuationKind::Not) => {
                let ((), r_bp) = prefix_bp(&TokenKind::Punctuation(PunctuationKind::Not)).expect(
                    "INTERNAL COMPILER ERROR: expected the not \'!\' symbol to have a corresponding prefix binding power",
                );
                let start_offset = self.offset;

                self.consume_punctuation(PunctuationKind::Not)?;
                let expr = self.parse_expr(r_bp)?;
                Expr {
                    kind: ExprKind::Not { right: Box::new(expr) },
                    span: self.get_span(start_offset, self.offset - 1)?,
                }
            }
            TokenKind::Keyword(KeywordKind::If) => self.parse_if_expr()?,
            TokenKind::Keyword(variant @ KeywordKind::True | variant @ KeywordKind::False) => {
                let start_offset = self.offset;
                self.consume_keyword(variant)?;
                let is_true = matches!(variant, KeywordKind::True);
                Expr {
                    kind: ExprKind::BoolLiteral(is_true),
                    span: self.get_span(start_offset, self.offset - 1)?,
                }
            }
            TokenKind::String(_) => {
                let value = self.consume_string()?;
                Expr {
                    span: value.span,
                    kind: ExprKind::String(value),
                }
            }
            _ => {
                return Err(ParsingError {
                    kind: ParsingErrorKind::ExpectedAnExpressionButFound(token.clone()),
                    span: token.span,
                })
            }
        };

        loop {
            let op = match self.current() {
                Some(o) => o.clone(),
                None => break,
            };

            if let Some((left_prec, ())) = suffix_bp(&op.kind) {
                if left_prec < min_prec {
                    break;
                }
                let lhs_clone = lhs.clone();

                let new_lhs = match op.kind {
                    TokenKind::Punctuation(PunctuationKind::Dot) => {
                        self.consume_punctuation(PunctuationKind::Dot)?;

                        let start_offset = self.offset;
                        let field = self.consume_identifier()?;
                        Some(Expr {
                            kind: ExprKind::Access {
                                left: Box::new(lhs_clone),
                                field,
                            },
                            span: self.get_span(start_offset, self.offset - 1)?,
                        })
                    }
                    TokenKind::Punctuation(PunctuationKind::DoubleCol) => {
                        let start_offset = self.offset;

                        self.consume_punctuation(PunctuationKind::DoubleCol)?;
                        let field = self.consume_identifier()?;
                        Some(Expr {
                            kind: ExprKind::StaticAccess {
                                left: Box::new(lhs_clone),
                                field,
                            },
                            span: self.get_span(start_offset, self.offset - 1)?,
                        })
                    }
                    TokenKind::Punctuation(PunctuationKind::LParen) => {
                        if let ExprKind::StaticAccess { left, field } = lhs.kind.clone() {
                            let is_type_cast = field.name == self.interner.intern("as");

                            if is_type_cast {
                                let start_offset = self.offset;
                                self.consume_punctuation(PunctuationKind::LParen)?;
                                let target_type = self.parse_type_annotation(0)?;
                                self.consume_punctuation(PunctuationKind::RParen)?;
                                let span_end = self.get_span(start_offset, self.offset - 1)?;

                                Some(Expr {
                                    kind: ExprKind::TypeCast {
                                        left,
                                        target: target_type,
                                    },
                                    span: Span {
                                        start: lhs.span.start,
                                        end: span_end.end,
                                    },
                                })
                            } else {
                                return Err(ParsingError {
                                    kind: ParsingErrorKind::UnknownStaticMethod(field),
                                    span: field.span,
                                });
                            }
                        } else {
                            Some(self.parse_fn_call_expr(lhs_clone)?)
                        }
                    }
                    TokenKind::Punctuation(PunctuationKind::LBrace) => {
                        let allow_lhs_kind = matches!(&lhs_clone.kind, ExprKind::Identifier(_));

                        if allow_lhs_kind {
                            Some(self.parse_struct_init_expr(lhs_clone)?)
                        } else {
                            None
                        }
                    }
                    _ => {
                        return Err(ParsingError {
                            span: op.span,
                            kind: ParsingErrorKind::InvalidSuffixOperator(op),
                        })
                    }
                };

                if let Some(expr) = new_lhs {
                    lhs = expr;
                    continue;
                }
            }

            if let Some((left_prec, right_prec)) = infix_bp(&op.kind) {
                if left_prec < min_prec {
                    break;
                }

                let start_pos = lhs.span.start;

                self.advance();

                let rhs = self.parse_expr(right_prec)?;

                let end_pos = rhs.span.end;

                let expr_kind = match op.kind {
                    TokenKind::Punctuation(PunctuationKind::Plus) => ExprKind::Add {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Minus) => ExprKind::Subtract {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Star) => ExprKind::Multiply {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Slash) => ExprKind::Divide {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Percent) => ExprKind::Modulo {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Lt) => ExprKind::LessThan {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Lte) => ExprKind::LessThanOrEqual {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Gt) => ExprKind::GreaterThan {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::Gte) => ExprKind::GreaterThanOrEqual {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::DoubleEq) => ExprKind::Equal {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::NotEq) => ExprKind::NotEqual {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::DoubleAnd) => ExprKind::And {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    TokenKind::Punctuation(PunctuationKind::DoubleOr) => ExprKind::Or {
                        left: Box::new(lhs),
                        right: Box::new(rhs),
                    },
                    _ => break,
                };

                lhs = Expr {
                    kind: expr_kind,
                    span: Span {
                        start: start_pos,
                        end: end_pos,
                    },
                };

                continue;
            }

            break;
        }

        Ok(lhs)
    }

    fn synchronize_expr(&mut self) {
        loop {
            match self.current() {
                Some(token) => {
                    if is_start_of_expr(&token.kind) {
                        return;
                    }
                    if token.kind == TokenKind::Punctuation(PunctuationKind::SemiCol) {
                        self.advance();
                        return;
                    }
                    if token.kind == TokenKind::Punctuation(PunctuationKind::RBrace) {
                        self.advance();
                        return;
                    }
                    if token.kind == TokenKind::Punctuation(PunctuationKind::RParen) {
                        self.advance();
                        return;
                    }
                    if token.kind == TokenKind::Punctuation(PunctuationKind::RBracket) {
                        self.advance();
                        return;
                    }
                    if token.kind == TokenKind::Punctuation(PunctuationKind::Comma) {
                        self.advance();
                        return;
                    }

                    self.advance();
                }
                None => return,
            }
        }
    }
}

```

`WillowLang/src/parse/expressions/parse_codeblock_expr.rs`:

```rs
use crate::{
    ast::{
        expr::{BlockContents, Expr},
        stmt::{Stmt, StmtKind},
        Span,
    },
    parse::{statements::is_start_of_stmt, Parser, ParsingError, ParsingErrorKind},
    tokenize::{PunctuationKind, TokenKind},
};

use super::is_start_of_expr;

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_codeblock_expr(&mut self) -> Result<BlockContents, ParsingError<'a>> {
        let start_offset = self.offset;
        self.consume_punctuation(PunctuationKind::LBrace)?;

        let mut statements = Vec::new();
        let mut final_expr: Option<Box<Expr>> = None;

        loop {
            if self.match_token(0, TokenKind::Punctuation(PunctuationKind::RBrace)) {
                break;
            }

            let current_token = self.current().ok_or_else(|| self.unexpected_end_of_input())?;

            if is_start_of_stmt(&current_token.kind) {
                if let Some(old_expr) = final_expr.take() {
                    statements.push(Stmt {
                        span: old_expr.span,
                        kind: StmtKind::Expression(*old_expr),
                    })
                }

                statements.push(self.parse_stmt()?);
            } else if is_start_of_expr(&current_token.kind) {
                if let Some(old_expr) = final_expr.take() {
                    statements.push(Stmt {
                        span: old_expr.span,
                        kind: StmtKind::Expression(*old_expr),
                    })
                }

                let expr = self.parse_expr(0)?;

                if self.match_token(0, TokenKind::Punctuation(PunctuationKind::Eq))
                    && !self.match_token(1, TokenKind::Punctuation(PunctuationKind::Eq))
                {
                    let stmt = self.parse_assignment_stmt(expr)?;
                    statements.push(stmt);
                } else if self.match_token(0, TokenKind::Punctuation(PunctuationKind::SemiCol)) {
                    let semi_token = self.current().unwrap();
                    let stmt = Stmt {
                        span: Span {
                            start: expr.span.start,
                            end: semi_token.span.end,
                        },
                        kind: StmtKind::Expression(expr),
                    };
                    statements.push(stmt);
                    self.advance();
                } else {
                    final_expr = Some(Box::new(expr));
                }
            } else {
                return Err(ParsingError {
                    kind: ParsingErrorKind::ExpectedStatementOrExpression {
                        found: current_token.kind.clone(),
                    },
                    span: current_token.span,
                });
            }
        }

        self.consume_punctuation(PunctuationKind::RBrace)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(BlockContents {
            statements,
            final_expr,
            span,
        })
    }
}

```

`WillowLang/src/parse/expressions/parse_enum_init_expr.rs`:

```rs
use crate::{
    ast::expr::{Expr, ExprKind},
    parse::{Parser, ParsingError},
    tokenize::PunctuationKind,
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_enum_init_expr(&mut self) -> Result<Expr, ParsingError<'a>> {
        todo!()
    }
}

```

`WillowLang/src/parse/expressions/parse_fn_call_expr.rs`:

```rs
use crate::{
    ast::expr::{Expr, ExprKind},
    parse::{Parser, ParsingError},
    tokenize::{PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_fn_call_args(&mut self) -> Result<Vec<Expr>, ParsingError<'a>> {
        self.consume_punctuation(PunctuationKind::LParen)?;
        let args = self.comma_separated(
            |p| p.parse_expr(0),
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RParen)),
        )?;
        self.consume_punctuation(PunctuationKind::RParen)?;
        Ok(args)
    }

    pub fn parse_fn_call_expr(&mut self, left: Expr) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;

        let args = self.parse_fn_call_args()?;
        let mut span = left.span;
        let end = self.get_span(start_offset, self.offset - 1)?;
        span.end = end.end;

        Ok(Expr {
            kind: ExprKind::FnCall {
                left: Box::new(left),
                args,
            },
            span,
        })
    }
}

```

`WillowLang/src/parse/expressions/parse_fn_expr.rs`:

```rs
use crate::{
    ast::{
        decl::Param,
        expr::{Expr, ExprKind},
    },
    parse::{Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_fn_expr(&mut self) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Fn)?;
        let name = self.consume_identifier()?;
        self.consume_punctuation(PunctuationKind::LParen)?;
        let params = self.comma_separated(
            |p| {
                let identifier = p.consume_identifier()?;
                p.consume_punctuation(PunctuationKind::Col)?;
                let constraint = p.parse_type_annotation(0)?;

                Ok(Param { constraint, identifier })
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RParen)),
        )?;
        self.consume_punctuation(PunctuationKind::RParen)?;
        self.consume_punctuation(PunctuationKind::Col)?;
        let return_type = self.parse_type_annotation(0)?;

        let body = self.parse_codeblock_expr()?;

        Ok(Expr {
            kind: ExprKind::Fn {
                name,
                params,
                return_type,
                body,
            },
            span: self.get_span(start_offset, self.offset - 1)?,
        })
    }
}

```

`WillowLang/src/parse/expressions/parse_if_expr.rs`:

```rs
use crate::{
    ast::expr::{BlockContents, Expr, ExprKind},
    parse::{Parser, ParsingError},
    tokenize::{KeywordKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_if_expr(&mut self) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;
        let mut branches: Vec<(Box<Expr>, BlockContents)> = Vec::new();

        self.consume_keyword(KeywordKind::If)?;
        let condition = self.parse_expr(0)?;
        let then_branch = self.parse_codeblock_expr()?;
        branches.push((Box::new(condition), then_branch));

        while self.match_token(0, TokenKind::Keyword(KeywordKind::Else))
            && self.match_token(1, TokenKind::Keyword(KeywordKind::If))
        {
            self.advance();
            self.advance();

            let else_if_condition = self.parse_expr(0)?;
            let else_if_body = self.parse_codeblock_expr()?;
            branches.push((Box::new(else_if_condition), else_if_body));
        }

        let else_branch = if self.match_token(0, TokenKind::Keyword(KeywordKind::Else)) {
            self.advance();

            let else_body = self.parse_codeblock_expr()?;
            Some(else_body)
        } else {
            None
        };

        Ok(Expr {
            kind: ExprKind::If { branches, else_branch },
            span: self.get_span(start_offset, self.offset - 1)?,
        })
    }
}

```

`WillowLang/src/parse/expressions/parse_list_literal_expr.rs`:

```rs
use crate::{
    ast::expr::{Expr, ExprKind},
    parse::{Parser, ParsingError},
    tokenize::{PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_list_literal_expr(&mut self) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;
        self.consume_punctuation(PunctuationKind::LBracket)?;
        let items: Vec<Expr> = self.comma_separated(
            |p| p.parse_expr(0),
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RBracket)),
        )?;
        self.consume_punctuation(PunctuationKind::RBracket)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Expr {
            kind: ExprKind::ListLiteral(items),
            span,
        })
    }
}

```

`WillowLang/src/parse/expressions/parse_match_expr.rs`:

```rs
use crate::{
    ast::expr::{Expr, ExprKind, MatchArm, MatchPattern},
    parse::{Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_match_expr(&mut self) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Match)?;
        let conditions = self.comma_separated(
            |p| p.parse_expr(0),
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::LBrace)),
        )?;
        self.consume_punctuation(PunctuationKind::LBrace)?;

        let arms = self.comma_separated(
            |p| {
                let patterns = p.comma_separated(
                    |pattern_parser| {
                        let variant_name = pattern_parser.consume_identifier()?;
                        if pattern_parser.match_token(0, TokenKind::Punctuation(PunctuationKind::LParen)) {
                            pattern_parser.advance();
                            let binding_name = pattern_parser.consume_identifier()?;
                            pattern_parser.consume_punctuation(PunctuationKind::RParen)?;
                            Ok(MatchPattern::VariantWithValue(variant_name, binding_name))
                        } else {
                            Ok(MatchPattern::Variant(variant_name))
                        }
                    },
                    |pattern_parser| pattern_parser.match_token(0, TokenKind::Punctuation(PunctuationKind::Eq)),
                )?;

                p.consume_punctuation(PunctuationKind::Eq)?;
                p.consume_punctuation(PunctuationKind::Gt)?;

                let expression = p.parse_expr(0)?;

                Ok(MatchArm {
                    expression,
                    pattern: patterns,
                })
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RBrace)),
        )?;
        self.consume_punctuation(PunctuationKind::RBrace)?;

        Ok(Expr {
            kind: ExprKind::Match { conditions, arms },
            span: self.get_span(start_offset, self.offset - 1)?,
        })
    }
}

```

`WillowLang/src/parse/expressions/parse_parenthesized_expr.rs`:

```rs
use crate::{
    ast::expr::Expr,
    parse::{Parser, ParsingError},
    tokenize::PunctuationKind,
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_parenthesized_expr(&mut self) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_punctuation(PunctuationKind::LParen)?;
        let expr = self.parse_expr(0)?;
        self.consume_punctuation(PunctuationKind::RParen)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Expr { kind: expr.kind, span })
    }
}

```

`WillowLang/src/parse/expressions/parse_struct_init_expr.rs`:

```rs
use crate::{
    ast::expr::{Expr, ExprKind},
    parse::{Parser, ParsingError},
    tokenize::{PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_struct_init_expr(&mut self, left: Expr) -> Result<Expr, ParsingError<'a>> {
        let start_offset = self.offset;
        let mut span = left.span;
        self.consume_punctuation(PunctuationKind::LBrace)?;
        let fields = self.comma_separated(
            |p| {
                let name = p.consume_identifier()?;
                p.consume_punctuation(PunctuationKind::Col)?;
                let value = p.parse_expr(0)?;
                Ok((name, value))
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RBrace)),
        )?;
        self.consume_punctuation(PunctuationKind::RBrace)?;

        let span_end = self.get_span(start_offset, self.offset - 1)?;
        span.end = span_end.end;

        Ok(Expr {
            kind: ExprKind::StructInit {
                left: Box::new(left),
                fields,
            },
            span,
        })
    }
}

```

`WillowLang/src/parse/mod.rs`:

```rs
mod expressions;
mod statements;
mod type_annotations;

pub struct Parser<'a, 'b> {
    pub offset: usize,
    pub tokens: Vec<Token<'a>>,
    pub checkpoint_offset: usize,
    pub interner: &'b mut StringInterner<'a>,
}

use unicode_segmentation::UnicodeSegmentation;

use crate::{
    ast::{stmt::Stmt, type_annotation::TypeAnnotation, IdentifierNode, Position, Span, StringNode},
    compile::string_interner::{InternerId, StringInterner},
    tokenize::{KeywordKind, NumberKind, PunctuationKind, Token, TokenKind},
};

#[derive(Debug, Clone, PartialEq)]
pub enum ParsingErrorKind<'a> {
    ExpectedATagTypeButFound(TypeAnnotation),
    DocMustBeFollowedByDeclaration,
    ExpectedAnExpressionButFound(Token<'a>),
    ExpectedATypeButFound(Token<'a>),
    InvalidSuffixOperator(Token<'a>),
    UnexpectedEndOfInput,
    ExpectedAnIdentifier,
    ExpectedAPunctuationMark(PunctuationKind),
    ExpectedAKeyword(KeywordKind),
    ExpectedAStringValue,
    ExpectedANumericValue,
    UnknownStaticMethod(IdentifierNode),
    UnexpectedStatementAfterFinalExpression,
    ExpectedStatementOrExpression { found: TokenKind<'a> },
    UnexpectedTokenAfterFinalExpression { found: TokenKind<'a> },
}

impl<'a> ParsingErrorKind<'a> {
    pub fn code(&self) -> usize {
        match self {
            ParsingErrorKind::DocMustBeFollowedByDeclaration { .. } => 1,
            ParsingErrorKind::ExpectedAnExpressionButFound(..) => 2,
            ParsingErrorKind::ExpectedATypeButFound(..) => 3,
            ParsingErrorKind::InvalidSuffixOperator(..) => 4,
            ParsingErrorKind::UnexpectedEndOfInput => 15,
            ParsingErrorKind::ExpectedAnIdentifier => 16,
            ParsingErrorKind::ExpectedAPunctuationMark(..) => 17,
            ParsingErrorKind::ExpectedAKeyword(..) => 18,
            ParsingErrorKind::ExpectedAStringValue => 19,
            ParsingErrorKind::ExpectedANumericValue => 20,
            ParsingErrorKind::UnknownStaticMethod(..) => 21,
            ParsingErrorKind::UnexpectedStatementAfterFinalExpression => 22,
            ParsingErrorKind::ExpectedStatementOrExpression { .. } => 23,
            ParsingErrorKind::UnexpectedTokenAfterFinalExpression { .. } => 24,
            ParsingErrorKind::ExpectedATagTypeButFound(..) => 25,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct ParsingError<'a> {
    pub kind: ParsingErrorKind<'a>,
    pub span: Span,
}

#[derive(Debug, Clone, PartialEq)]
pub struct DocAnnotation {
    message: InternerId,
    span: Span,
}

impl<'a, 'b> Parser<'a, 'b> {
    fn match_token(&self, index: usize, kind: TokenKind) -> bool {
        if let Some(token) = self.tokens.get(self.offset + index) {
            return token.kind == kind;
        }

        false
    }

    fn advance(&mut self) {
        self.offset += 1;
    }

    fn current(&self) -> Option<&Token<'a>> {
        self.tokens.get(self.offset)
    }

    fn unexpected_end_of_input(&self) -> ParsingError<'a> {
        // TODO: fix this
        let first_token_span = Span {
            start: Position {
                line: 1,
                col: 1,
                byte_offset: 0,
            },
            end: Position {
                line: 1,
                col: 1,
                byte_offset: 0,
            },
        };

        let last_token_span = self.tokens.last().map(|t| &t.span).unwrap_or(&first_token_span);

        ParsingError {
            kind: ParsingErrorKind::UnexpectedEndOfInput,
            span: *last_token_span,
        }
    }

    fn get_span(&mut self, start_offset: usize, end_offset: usize) -> Result<Span, ParsingError<'a>> {
        let start = self.tokens.get(start_offset).ok_or(self.unexpected_end_of_input())?;

        let end = self.tokens.get(end_offset).ok_or(self.unexpected_end_of_input())?;

        Ok(Span {
            start: start.span.start,
            end: end.span.end,
        })
    }

    fn place_checkpoint(&mut self) {
        self.checkpoint_offset = self.offset;
    }

    fn goto_checkpoint(&mut self) {
        self.offset = self.checkpoint_offset;
    }

    pub fn consume_string(&mut self) -> Result<StringNode, ParsingError<'a>> {
        if let Some(t) = self.current() {
            let span = t.span;
            match t.kind {
                TokenKind::String(value) => {
                    self.advance();

                    Ok(StringNode {
                        span,
                        len: value.graphemes(true).count(),
                        value: self.interner.intern(&value),
                    })
                }
                _ => {
                    return Err(ParsingError {
                        kind: ParsingErrorKind::ExpectedAStringValue,
                        span: t.span,
                    })
                }
            }
        } else {
            Err(self.unexpected_end_of_input())
        }
    }

    pub fn consume_punctuation(&mut self, expected: PunctuationKind) -> Result<(), ParsingError<'a>> {
        if let Some(token) = self.current() {
            match &token.kind {
                TokenKind::Punctuation(pk) if *pk == expected => {
                    self.advance();
                    Ok(())
                }
                _ => Err(ParsingError {
                    kind: ParsingErrorKind::ExpectedAPunctuationMark(expected),
                    span: token.span,
                }),
            }
        } else {
            Err(self.unexpected_end_of_input())
        }
    }

    pub fn consume_number(&mut self) -> Result<NumberKind, ParsingError<'a>> {
        if let Some(token) = self.current() {
            match token.kind {
                TokenKind::Number(number_kind) => {
                    self.advance();
                    return Ok(number_kind);
                }
                _ => {
                    return Err(ParsingError {
                        kind: ParsingErrorKind::ExpectedANumericValue,
                        span: token.span,
                    })
                }
            }
        }

        Err(self.unexpected_end_of_input())
    }

    pub fn consume_keyword(&mut self, expected: KeywordKind) -> Result<(), ParsingError<'a>> {
        if let Some(token) = self.current() {
            match token.kind {
                TokenKind::Keyword(keyword_kind) if keyword_kind == expected => {
                    self.advance();
                    Ok(())
                }
                _ => Err(ParsingError {
                    kind: ParsingErrorKind::ExpectedAKeyword(expected),
                    span: token.span,
                }),
            }
        } else {
            Err(self.unexpected_end_of_input())
        }
    }

    pub fn consume_identifier(&mut self) -> Result<IdentifierNode, ParsingError<'a>> {
        if let Some(token) = self.current() {
            match token.kind {
                TokenKind::Identifier(id) => {
                    let span = token.span;
                    let name = self.interner.intern(id);
                    self.advance();
                    Ok(IdentifierNode { name, span })
                }
                _ => Err(ParsingError {
                    kind: ParsingErrorKind::ExpectedAnIdentifier,
                    span: token.span,
                }),
            }
        } else {
            Err(self.unexpected_end_of_input())
        }
    }

    pub fn consume_optional_doc(&mut self) -> Option<DocAnnotation> {
        let result = if let Some(Token {
            kind: TokenKind::Doc(doc),
            span,
        }) = self.current()
        {
            Some(DocAnnotation {
                span: *span,
                message: self.interner.intern(&doc),
            })
        } else {
            None
        };

        if result.is_some() {
            self.advance();
        };

        result
    }

    pub fn comma_separated<F, T, E>(&mut self, mut parser: F, is_end: E) -> Result<Vec<T>, ParsingError<'a>>
    where
        F: FnMut(&mut Self) -> Result<T, ParsingError<'a>>,
        E: Fn(&Self) -> bool,
    {
        let mut items = Vec::new();

        if is_end(self) {
            return Ok(items);
        }

        let first_item = parser(self)?;
        items.push(first_item);

        loop {
            if is_end(self) {
                break;
            }

            self.consume_punctuation(PunctuationKind::Comma)?;

            if is_end(self) {
                break;
            }

            let item = parser(self)?;
            items.push(item);
        }

        Ok(items)
    }

    pub fn parse(tokens: Vec<Token<'a>>, interner: &'b mut StringInterner<'a>) -> (Vec<Stmt>, Vec<ParsingError<'a>>) {
        let mut state = Parser {
            offset: 0,
            checkpoint_offset: 0,
            tokens,
            interner,
        };

        let mut statements: Vec<Stmt> = vec![];
        let mut errors: Vec<ParsingError<'a>> = vec![];

        while state.current().is_some() {
            let stmt = state.parse_stmt();
            match stmt {
                Ok(s) => {
                    statements.push(s);
                }
                Err(e) => {
                    errors.push(e);
                }
            }
        }

        (statements, errors)
    }
}

```

`WillowLang/src/parse/statements/mod.rs`:

```rs
pub mod parse_assignment_stmt;
pub mod parse_break_stmt;
pub mod parse_continue_stmt;
pub mod parse_enum_decl;
pub mod parse_expr_stmt;
pub mod parse_from_stmt;
pub mod parse_return_stmt;
pub mod parse_struct_decl;
pub mod parse_type_alias_decl;
pub mod parse_var_decl;
pub mod parse_while_stmt;

use crate::{
    ast::{
        stmt::{Stmt, StmtKind},
        Span,
    },
    parse::{Parser, ParsingErrorKind},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

use super::ParsingError;

pub fn is_start_of_stmt(token_kind: &TokenKind) -> bool {
    matches!(
        token_kind,
        TokenKind::Keyword(
            KeywordKind::From
                | KeywordKind::While
                | KeywordKind::Return
                | KeywordKind::Break
                | KeywordKind::Continue
                | KeywordKind::Type
                | KeywordKind::Let
        ) | TokenKind::Doc(_)
    )
}

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_stmt(&mut self) -> Result<Stmt, ParsingError<'a>> {
        let result = if self.match_token(0, TokenKind::Keyword(KeywordKind::From)) {
            self.parse_from_stmt()
        } else if self.match_token(0, TokenKind::Keyword(KeywordKind::While)) {
            self.parse_while_stmt()
        } else if self.match_token(0, TokenKind::Keyword(KeywordKind::Return)) {
            self.parse_return_stmt()
        } else if self.match_token(0, TokenKind::Keyword(KeywordKind::Break)) {
            self.parse_break_stmt()
        } else if self.match_token(0, TokenKind::Keyword(KeywordKind::Continue)) {
            self.parse_continue_stmt()
        } else {
            let documentation = self.consume_optional_doc();

            if self.match_token(0, TokenKind::Keyword(KeywordKind::Let)) {
                self.parse_var_decl(documentation)
            } else if self.match_token(0, TokenKind::Keyword(KeywordKind::Type)) {
                self.parse_type_alias_decl(documentation)
            } else if self.match_token(0, TokenKind::Keyword(KeywordKind::Struct)) {
                self.parse_struct_decl(documentation)
            } else if self.match_token(0, TokenKind::Keyword(KeywordKind::Enum)) {
                self.parse_enum_decl(documentation)
            } else if let Some(doc) = documentation {
                Err(ParsingError {
                    kind: ParsingErrorKind::DocMustBeFollowedByDeclaration,
                    span: doc.span,
                })
            } else {
                let lhs = self.parse_expr(0);

                match lhs {
                    Ok(lhs) => {
                        if self.match_token(0, TokenKind::Punctuation(PunctuationKind::Eq))
                            && !self.match_token(1, TokenKind::Punctuation(PunctuationKind::Eq))
                        {
                            // It's an assignment statement
                            self.parse_assignment_stmt(lhs)
                        } else {
                            // It's a standalone expression statement
                            let mut end_span = lhs.span;
                            if self.match_token(0, TokenKind::Punctuation(PunctuationKind::SemiCol)) {
                                end_span = self.current().unwrap().span;
                                self.advance();
                            }

                            Ok(Stmt {
                                span: Span {
                                    start: lhs.span.start,
                                    end: end_span.end,
                                },
                                kind: StmtKind::Expression(lhs),
                            })
                        }
                    }
                    Err(e) => Err(e),
                }
            }
        };

        result.map_err(|e| {
            self.synchronize_stmt();
            e
        })
    }

    pub fn synchronize_stmt(&mut self) {
        loop {
            match self.current() {
                Some(token) => {
                    if token.kind == TokenKind::Punctuation(PunctuationKind::SemiCol) {
                        self.advance();
                        return;
                    }

                    self.advance();
                }
                None => return,
            }
        }
    }
}

```

`WillowLang/src/parse/statements/parse_assignment_stmt.rs`:

```rs
use crate::{
    ast::{
        expr::Expr,
        stmt::{Stmt, StmtKind},
        Span,
    },
    parse::{Parser, ParsingError},
    tokenize::PunctuationKind,
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_assignment_stmt(&mut self, lhs: Expr) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;
        self.consume_punctuation(PunctuationKind::Eq)?;
        let value = self.parse_expr(0)?;
        self.consume_punctuation(PunctuationKind::SemiCol)?;
        let span_end = self.get_span(start_offset, self.offset - 1)?;
        Ok(Stmt {
            span: Span {
                start: lhs.span.start,
                end: span_end.end,
            },
            kind: StmtKind::Assignment { target: lhs, value },
        })
    }
}

```

`WillowLang/src/parse/statements/parse_break_stmt.rs`:

```rs
use crate::{
    ast::stmt::{Stmt, StmtKind},
    parse::{Parser, ParsingError},
    tokenize::KeywordKind,
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_break_stmt(&mut self) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;
        self.consume_keyword(KeywordKind::Break)?;
        let span = self.get_span(start_offset, self.offset - 1)?;
        return Ok(Stmt {
            kind: StmtKind::Break,
            span,
        });
    }
}

```

`WillowLang/src/parse/statements/parse_continue_stmt.rs`:

```rs
use crate::{
    ast::stmt::{Stmt, StmtKind},
    parse::{Parser, ParsingError},
    tokenize::KeywordKind,
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_continue_stmt(&mut self) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;
        self.consume_keyword(KeywordKind::Continue)?;
        let span = self.get_span(start_offset, self.offset - 1)?;
        return Ok(Stmt {
            kind: StmtKind::Continue,
            span,
        });
    }
}

```

`WillowLang/src/parse/statements/parse_enum_decl.rs`:

```rs
use crate::{
    ast::{
        decl::{EnumDecl, EnumDeclVariant},
        stmt::{Stmt, StmtKind},
    },
    parse::{DocAnnotation, Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_enum_decl(&mut self, documentation: Option<DocAnnotation>) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Enum)?;
        let identifier = self.consume_identifier()?;
        self.consume_punctuation(PunctuationKind::LBrace)?;
        let variants = self.comma_separated(
            |p| {
                let name = p.consume_identifier()?;
                let payload = if p.match_token(0, TokenKind::Punctuation(PunctuationKind::LParen)) {
                    p.consume_punctuation(PunctuationKind::LParen)?;
                    let ty = p.parse_type_annotation(0)?;
                    p.consume_punctuation(PunctuationKind::RParen)?;
                    Some(ty)
                } else {
                    None
                };

                Ok(EnumDeclVariant { name, payload })
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RBrace)),
        )?;
        self.consume_punctuation(PunctuationKind::RBrace)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Stmt {
            kind: StmtKind::EnumDecl(EnumDecl {
                documentation,
                identifier,
                variants,
            }),
            span,
        })
    }
}

```

`WillowLang/src/parse/statements/parse_expr_stmt.rs`:

```rs
use crate::{
    ast::{
        expr::Expr,
        stmt::{Stmt, StmtKind},
    },
    parse::{Parser, ParsingError},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_expr_stmt(&mut self, lhs: Expr) -> Result<Stmt, ParsingError<'a>> {
        Ok(Stmt {
            span: lhs.span,
            kind: StmtKind::Expression(lhs),
        })
    }
}

```

`WillowLang/src/parse/statements/parse_from_stmt.rs`:

```rs
use crate::{
    ast::stmt::{Stmt, StmtKind},
    parse::{Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_from_stmt(&mut self) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::From)?;
        let path = self.consume_string()?;

        self.consume_punctuation(PunctuationKind::LBrace)?;
        let identifiers = self.comma_separated(
            |p| {
                let identifier = p.consume_identifier()?;
                let alias = if p.match_token(0, TokenKind::Punctuation(PunctuationKind::Col)) {
                    p.advance();
                    Some(p.consume_identifier()?)
                } else {
                    None
                };

                Ok((identifier, alias))
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RBrace)),
        )?;
        self.consume_punctuation(PunctuationKind::RBrace)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        return Ok(Stmt {
            kind: StmtKind::From { path, identifiers },
            span,
        });
    }
}

```

`WillowLang/src/parse/statements/parse_return_stmt.rs`:

```rs
use crate::{
    ast::stmt::{Stmt, StmtKind},
    parse::{Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_return_stmt(&mut self) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Return)?;
        let value = self.parse_expr(0)?;
        self.consume_punctuation(PunctuationKind::SemiCol)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        return Ok(Stmt {
            kind: StmtKind::Return { value },
            span,
        });
    }
}

```

`WillowLang/src/parse/statements/parse_struct_decl.rs`:

```rs
use crate::{
    ast::{
        decl::{Param, StructDecl},
        stmt::{Stmt, StmtKind},
    },
    parse::{DocAnnotation, Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_struct_decl(&mut self, documentation: Option<DocAnnotation>) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Struct)?;
        let name = self.consume_identifier()?;
        self.consume_punctuation(PunctuationKind::LBrace)?;
        let fields = self.comma_separated(
            |p| {
                let name = p.consume_identifier()?;
                p.consume_punctuation(PunctuationKind::Col)?;
                let constraint = p.parse_type_annotation(0)?;

                Ok(Param {
                    constraint,
                    identifier: name,
                })
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RBrace)),
        )?;
        self.consume_punctuation(PunctuationKind::RBrace)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Stmt {
            kind: StmtKind::StructDecl(StructDecl {
                identifier: name,
                documentation,
                fields,
            }),
            span,
        })
    }
}

```

`WillowLang/src/parse/statements/parse_type_alias_decl.rs`:

```rs
use crate::{
    ast::{
        decl::TypeAliasDecl,
        stmt::{Stmt, StmtKind},
    },
    parse::{DocAnnotation, Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_type_alias_decl(&mut self, documentation: Option<DocAnnotation>) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Type)?;

        let name = self.consume_identifier()?;

        self.consume_punctuation(PunctuationKind::Eq)?;

        let ty = self.parse_type_annotation(0)?;

        self.consume_punctuation(PunctuationKind::SemiCol)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Stmt {
            kind: StmtKind::TypeAliasDecl(TypeAliasDecl {
                identifier: name,
                documentation,
                value: ty,
            }),
            span,
        })
    }
}

```

`WillowLang/src/parse/statements/parse_var_decl.rs`:

```rs
use crate::{
    ast::{
        decl::VarDecl,
        stmt::{Stmt, StmtKind},
    },
    parse::{DocAnnotation, Parser, ParsingError},
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_var_decl(&mut self, documentation: Option<DocAnnotation>) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Let)?;

        let name = self.consume_identifier()?;

        let constraint = if self.match_token(0, TokenKind::Punctuation(PunctuationKind::Col)) {
            self.advance();
            Some(self.parse_type_annotation(0)?)
        } else {
            None
        };

        let value = if self.match_token(0, TokenKind::Punctuation(PunctuationKind::Eq)) {
            self.consume_punctuation(PunctuationKind::Eq)?;
            Some(self.parse_expr(0)?)
        } else {
            None
        };

        self.consume_punctuation(PunctuationKind::SemiCol)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Stmt {
            kind: StmtKind::VarDecl(VarDecl {
                documentation,
                identifier: name,
                constraint,
                value,
            }),
            span,
        })
    }
}

```

`WillowLang/src/parse/statements/parse_while_stmt.rs`:

```rs
use crate::{
    ast::stmt::{Stmt, StmtKind},
    parse::{Parser, ParsingError},
    tokenize::KeywordKind,
};

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_while_stmt(&mut self) -> Result<Stmt, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::While)?;
        let condition = Box::new(self.parse_expr(0)?);
        let body = self.parse_codeblock_expr()?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(Stmt {
            kind: StmtKind::While { condition, body },
            span,
        })
    }
}

```

`WillowLang/src/parse/type_annotations/mod.rs`:

```rs
pub mod parse_fn_type_annotation;
pub mod parse_parenthesized_type_annotation;

use super::{Parser, ParsingError, ParsingErrorKind};
use crate::{
    ast::{
        expr::BorrowKind,
        type_annotation::{TypeAnnotation, TypeAnnotationKind},
    },
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

fn suffix_bp(token_kind: &TokenKind) -> Option<(u8, ())> {
    use PunctuationKind::*;
    use TokenKind::*;

    let priority = match token_kind {
        Punctuation(LBracket) => (3, ()),
        _ => return None,
    };

    Some(priority)
}

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_type_annotation(&mut self, min_prec: u8) -> Result<TypeAnnotation, ParsingError<'a>> {
        let token = self.current().ok_or(self.unexpected_end_of_input())?;

        let mut lhs = match token.kind {
            TokenKind::Keyword(KeywordKind::Void) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::Void)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::Void,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::Bool) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::Bool)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::Bool,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::U8) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::U8)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::U8,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::U16) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::U16)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::U16,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::U32) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::U32)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::U32,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::U64) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::U64)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::U64,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::USize) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::USize)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::USize,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::ISize) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::ISize)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::ISize,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::I8) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::I8)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::I8,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::I16) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::I16)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::I16,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::I32) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::I32)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::I32,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::I64) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::I64)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::I64,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::F32) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::F32)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::F32,
                    span,
                }
            }
            TokenKind::Keyword(KeywordKind::F64) => {
                let start_offset = self.offset;

                self.consume_keyword(KeywordKind::F64)?;
                let span = self.get_span(start_offset, self.offset - 1)?;
                TypeAnnotation {
                    kind: TypeAnnotationKind::F64,
                    span,
                }
            }
            TokenKind::Punctuation(PunctuationKind::LParen) => self.parse_parenthesized_type_annotation()?,
            TokenKind::Keyword(KeywordKind::Fn) => self.parse_fn_type_annotation()?,
            TokenKind::Identifier(_) => {
                let identifier = self.consume_identifier()?;
                TypeAnnotation {
                    span: identifier.span,
                    kind: TypeAnnotationKind::Identifier(identifier),
                }
            }
            TokenKind::Punctuation(PunctuationKind::And) => {
                let start_offset = self.offset;

                self.advance();
                let kind = if self.match_token(0, TokenKind::Keyword(KeywordKind::Mut)) {
                    self.advance();
                    BorrowKind::Mutable
                } else {
                    BorrowKind::Shared
                };

                let value = Box::new(self.parse_type_annotation(0)?);

                TypeAnnotation {
                    kind: TypeAnnotationKind::Borrow { kind, value },
                    span: self.get_span(start_offset, self.offset - 1)?,
                }
            }
            _ => {
                return Err(ParsingError {
                    kind: ParsingErrorKind::ExpectedATypeButFound(token.clone()),
                    span: token.span,
                })
            }
        };

        Ok(lhs)
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        ast::{
            type_annotation::{TypeAnnotation, TypeAnnotationKind},
            Span,
        },
        compile::string_interner::StringInterner,
        parse::Parser,
    };

    #[test]
    fn parses_primitive_types() {
        use crate::ast::Position;
        use crate::tokenize::Tokenizer;
        use pretty_assertions::assert_eq;

        let test_cases = vec![
            (
                "i8",
                TypeAnnotation {
                    kind: TypeAnnotationKind::I8,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 3,
                            byte_offset: 2,
                        },
                    },
                },
            ),
            (
                "i16",
                TypeAnnotation {
                    kind: TypeAnnotationKind::I16,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "i32",
                TypeAnnotation {
                    kind: TypeAnnotationKind::I32,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "i64",
                TypeAnnotation {
                    kind: TypeAnnotationKind::I64,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "f32",
                TypeAnnotation {
                    kind: TypeAnnotationKind::F32,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "f64",
                TypeAnnotation {
                    kind: TypeAnnotationKind::F64,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "u8",
                TypeAnnotation {
                    kind: TypeAnnotationKind::U8,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 3,
                            byte_offset: 2,
                        },
                    },
                },
            ),
            (
                "u16",
                TypeAnnotation {
                    kind: TypeAnnotationKind::U16,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "u32",
                TypeAnnotation {
                    kind: TypeAnnotationKind::U32,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "u64",
                TypeAnnotation {
                    kind: TypeAnnotationKind::U64,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 4,
                            byte_offset: 3,
                        },
                    },
                },
            ),
            (
                "usize",
                TypeAnnotation {
                    kind: TypeAnnotationKind::USize,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 6,
                            byte_offset: 5,
                        },
                    },
                },
            ),
            (
                "void",
                TypeAnnotation {
                    kind: TypeAnnotationKind::Void,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 5,
                            byte_offset: 4,
                        },
                    },
                },
            ),
            (
                "bool",
                TypeAnnotation {
                    kind: TypeAnnotationKind::Bool,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 5,
                            byte_offset: 4,
                        },
                    },
                },
            ),
            (
                "string",
                TypeAnnotation {
                    kind: TypeAnnotationKind::String,
                    span: Span {
                        start: Position {
                            line: 1,
                            col: 1,
                            byte_offset: 0,
                        },
                        end: Position {
                            line: 1,
                            col: 7,
                            byte_offset: 6,
                        },
                    },
                },
            ),
        ];

        for (input, expected) in test_cases {
            let (tokens, _) = Tokenizer::tokenize(input);
            let mut parser = Parser {
                offset: 0,
                checkpoint_offset: 0,
                tokens,
                interner: &mut StringInterner::new(),
            };
            let result = parser.parse_type_annotation(0);

            assert_eq!(result, Ok(expected))
        }
    }
}

```

`WillowLang/src/parse/type_annotations/parse_fn_type_annotation.rs`:

```rs
use crate::{
    ast::{
        decl::Param,
        type_annotation::{TypeAnnotation, TypeAnnotationKind},
    },
    parse::ParsingError,
    tokenize::{KeywordKind, PunctuationKind, TokenKind},
};

use super::Parser;

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_fn_type_annotation(&mut self) -> Result<TypeAnnotation, ParsingError<'a>> {
        let start_offset = self.offset;

        self.consume_keyword(KeywordKind::Fn)?;
        self.consume_punctuation(PunctuationKind::LParen)?;
        let params = self.comma_separated(
            |p| {
                let identifier = p.consume_identifier()?;
                p.consume_punctuation(PunctuationKind::Col)?;
                let constraint = p.parse_type_annotation(0)?;

                Ok(Param { constraint, identifier })
            },
            |p| p.match_token(0, TokenKind::Punctuation(PunctuationKind::RParen)),
        )?;
        self.consume_punctuation(PunctuationKind::RParen)?;
        self.consume_punctuation(PunctuationKind::Col)?;
        let return_type = self.parse_type_annotation(0)?;

        let span = self.get_span(start_offset, self.offset - 1)?;

        Ok(TypeAnnotation {
            kind: TypeAnnotationKind::FnType {
                params,
                return_type: Box::new(return_type),
            },
            span,
        })
    }
}

```

`WillowLang/src/parse/type_annotations/parse_parenthesized_type_annotation.rs`:

```rs
use crate::{ast::type_annotation::TypeAnnotation, parse::ParsingError, tokenize::PunctuationKind};

use super::Parser;

impl<'a, 'b> Parser<'a, 'b> {
    pub fn parse_parenthesized_type_annotation(&mut self) -> Result<TypeAnnotation, ParsingError<'a>> {
        self.consume_punctuation(PunctuationKind::LParen)?;
        let item = self.parse_type_annotation(0)?;
        self.consume_punctuation(PunctuationKind::RParen)?;

        Ok(item)
    }
}

```

`WillowLang/src/tokenize/mod.rs`:

```rs
use unicode_segmentation::UnicodeSegmentation;

pub mod tokenize_documentation;
pub mod tokenize_identifier;
pub mod tokenize_number;
pub mod tokenize_punctuation;
pub mod tokenize_string;

use crate::ast::{Position, Span};

#[derive(Debug, Clone, PartialEq)]
pub enum TokenizationErrorKind {
    UnknownToken,
    UnknownEscapeSequence,
    InvalidFloatingNumber,
    InvalidIntegerNumber,
    UnterminatedString,
    UnterminatedDoc,
}

impl TokenizationErrorKind {
    pub fn code(&self) -> usize {
        match self {
            TokenizationErrorKind::UnknownToken => 1,
            TokenizationErrorKind::UnknownEscapeSequence => 2,
            TokenizationErrorKind::InvalidFloatingNumber => 3,
            TokenizationErrorKind::InvalidIntegerNumber => 4,
            TokenizationErrorKind::UnterminatedString => 5,
            TokenizationErrorKind::UnterminatedDoc => 6,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct TokenizationError {
    pub kind: TokenizationErrorKind,
    pub span: Span,
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum PunctuationKind {
    DoubleCol,
    DoubleOr,
    DoubleAnd,
    DoubleEq,
    Col,
    SemiCol,
    Lt,
    Gt,
    Lte,
    Gte,
    Or,
    And,
    Not,
    Dot,
    LParen,
    RParen,
    LBracket,
    RBracket,
    LBrace,
    RBrace,
    Eq,
    NotEq,
    Plus,
    Minus,
    Slash,
    Star,
    Percent,
    Comma,
    Dollar,
    Question,
}

impl PunctuationKind {
    pub fn to_string(&self) -> String {
        String::from(match self {
            PunctuationKind::DoubleCol => "::",
            PunctuationKind::DoubleOr => "||",
            PunctuationKind::DoubleAnd => "&&",
            PunctuationKind::DoubleEq => "==",
            PunctuationKind::Col => ":",
            PunctuationKind::SemiCol => ";",
            PunctuationKind::Lt => "<",
            PunctuationKind::Gt => ">",
            PunctuationKind::Lte => "<=",
            PunctuationKind::Gte => ">=",
            PunctuationKind::Or => "|",
            PunctuationKind::And => "&",
            PunctuationKind::Not => "!",
            PunctuationKind::Dot => ".",
            PunctuationKind::LParen => "(",
            PunctuationKind::RParen => ")",
            PunctuationKind::LBracket => "[",
            PunctuationKind::RBracket => "]",
            PunctuationKind::LBrace => "{",
            PunctuationKind::RBrace => "}",
            PunctuationKind::Eq => "=",
            PunctuationKind::NotEq => "!=",
            PunctuationKind::Plus => "+",
            PunctuationKind::Minus => "-",
            PunctuationKind::Slash => "/",
            PunctuationKind::Star => "*",
            PunctuationKind::Percent => "%",
            PunctuationKind::Comma => ",",
            PunctuationKind::Dollar => "$",
            PunctuationKind::Question => "?",
        })
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum KeywordKind {
    Let,
    Return,
    If,
    Else,
    While,
    Break,
    Continue,
    Type,
    From,
    Void,
    True,
    False,
    Pub,
    Bool,
    I8,
    I16,
    I32,
    I64,
    U8,
    U16,
    U32,
    U64,
    USize,
    ISize,
    F32,
    F64,
    Fn,
    Match,
    Enum,
    Struct,
    Mut,
}

impl KeywordKind {
    pub fn to_string(&self) -> String {
        String::from(match self {
            KeywordKind::Let => "let",
            KeywordKind::Return => "return",
            KeywordKind::If => "if",
            KeywordKind::Else => "else",
            KeywordKind::While => "while",
            KeywordKind::Break => "break",
            KeywordKind::Continue => "continue",
            KeywordKind::Type => "type",
            KeywordKind::From => "from",
            KeywordKind::Void => "void",
            KeywordKind::True => "true",
            KeywordKind::False => "false",
            KeywordKind::Pub => "pub",
            KeywordKind::Bool => "bool",
            KeywordKind::I8 => "i8",
            KeywordKind::I16 => "i16",
            KeywordKind::I32 => "i32",
            KeywordKind::I64 => "i64",
            KeywordKind::U8 => "u8",
            KeywordKind::U16 => "u16",
            KeywordKind::U32 => "u32",
            KeywordKind::U64 => "u64",
            KeywordKind::USize => "usize",
            KeywordKind::ISize => "isize",
            KeywordKind::F32 => "f32",
            KeywordKind::F64 => "f64",
            KeywordKind::Fn => "fn",
            KeywordKind::Match => "match",
            KeywordKind::Enum => "enum",
            KeywordKind::Struct => "struct",
            KeywordKind::Mut => "mut",
        })
    }
}

#[derive(Debug, PartialEq, Copy, Clone)]
pub enum NumberKind {
    I64(i64),
    I32(i32),
    I16(i16),
    I8(i8),
    F32(f32),
    F64(f64),
    U64(u64),
    U32(u32),
    U16(u16),
    U8(u8),
    USize(usize),
    ISize(isize),
}

impl NumberKind {
    pub fn to_string(&self) -> String {
        match self {
            NumberKind::I64(v) => format!("{}i64", v),
            NumberKind::I32(v) => format!("{}i32", v),
            NumberKind::I16(v) => format!("{}i16", v),
            NumberKind::I8(v) => format!("{}i8", v),
            NumberKind::F32(v) => format!("{}f32", v),
            NumberKind::F64(v) => format!("{}f64", v),
            NumberKind::U64(v) => format!("{}u64", v),
            NumberKind::U32(v) => format!("{}u32", v),
            NumberKind::U16(v) => format!("{}u16", v),
            NumberKind::U8(v) => format!("{}u8", v),
            NumberKind::USize(v) => format!("{}usize", v),
            NumberKind::ISize(v) => format!("{}isize", v),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum TokenKind<'a> {
    Identifier(&'a str),
    Punctuation(PunctuationKind),
    Keyword(KeywordKind),
    String(&'a str),
    Number(NumberKind),
    Doc(&'a str),
}

pub fn token_kind_to_string(kind: &TokenKind) -> String {
    match *kind {
        TokenKind::Identifier(id) => id.to_owned(),
        TokenKind::Punctuation(punctuation_kind) => punctuation_kind.to_string(),
        TokenKind::Keyword(keyword_kind) => keyword_kind.to_string(),
        TokenKind::String(value) => value.to_owned(),
        TokenKind::Number(number_kind) => number_kind.to_string(),
        TokenKind::Doc(value) => format!("---\n{}\n---", value),
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Token<'a> {
    pub span: Span,
    pub kind: TokenKind<'a>,
}

#[derive(Debug)]
pub struct Tokenizer<'a> {
    input: &'a str,
    byte_offset: usize,
    grapheme_offset: usize,
    line: usize,
    col: usize,
}

impl<'a> Tokenizer<'a> {
    fn current(&self) -> Option<&'a str> {
        self.input.graphemes(true).nth(self.grapheme_offset)
    }

    fn consume(&mut self) {
        if let Some(c) = self.current() {
            if c == "\n" {
                self.byte_offset += c.len();
                self.line += 1;
                self.col = 1;
            } else {
                self.byte_offset += c.len();
                self.col += 1;
            }
            self.grapheme_offset += 1;
        }
    }

    fn peek(&self, i: usize) -> Option<&'a str> {
        self.input.graphemes(true).nth(self.grapheme_offset + i)
    }

    fn slice(&self, start: usize, end: usize) -> &'a str {
        let grapheme_indices: Vec<(usize, &str)> = self.input.grapheme_indices(true).collect();

        let start_idx = grapheme_indices[start].0;
        let end_idx = if end < grapheme_indices.len() {
            grapheme_indices[end].0
        } else {
            self.input.len()
        };

        &self.input[start_idx..end_idx]
    }

    fn synchronize(&mut self) {
        while let Some(ch) = self.current() {
            let is_whitespace = ch.chars().all(|c| c.is_whitespace());

            if is_whitespace || ch == ";" {
                self.consume();
                break;
            } else {
                self.consume();
            }
        }
    }

    fn skip_whitespace(&mut self) {
        while let Some(ch) = self.current() {
            let is_whitespace = ch.chars().all(|c| c.is_whitespace());

            if is_whitespace {
                self.consume();
            } else {
                break;
            }
        }
    }

    fn skip_comment(&mut self) {
        if self.peek(0) == Some("/") && self.peek(1) == Some("/") {
            while let Some(c) = self.current() {
                if c == "\n" {
                    break;
                }
                self.consume();
            }
        }
    }

    pub fn tokenize(input: &'a str) -> (Vec<Token<'a>>, Vec<TokenizationError>) {
        let mut state = Tokenizer {
            input,
            byte_offset: 0,
            grapheme_offset: 0,
            line: 1,
            col: 1,
        };
        let mut tokens: Vec<Token<'a>> = vec![];
        let mut errors: Vec<TokenizationError> = vec![];

        loop {
            state.skip_whitespace();
            state.skip_comment();

            let start_pos = Position {
                line: state.line,
                col: state.col,
                byte_offset: state.byte_offset,
            };

            match state.current() {
                Some(letter) if is_letter(letter) => {
                    let identifier = state.tokenize_identifier();
                    let keyword = is_keyword(&identifier);
                    let kind = if let Some(keyword_kind) = keyword {
                        TokenKind::Keyword(keyword_kind)
                    } else {
                        TokenKind::Identifier(identifier)
                    };
                    let end_pos = Position {
                        line: state.line,
                        col: state.col,
                        byte_offset: state.byte_offset,
                    };

                    tokens.push(Token {
                        span: Span {
                            start: start_pos,
                            end: end_pos,
                        },
                        kind,
                    });
                }
                Some("\"") => match state.string() {
                    Ok(value) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        tokens.push(Token {
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                            kind: TokenKind::String(value),
                        })
                    }
                    Err(kind) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        errors.push(TokenizationError {
                            kind,
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        });
                        state.synchronize();
                    }
                },
                Some(digit) if is_digit(digit) => match state.tokenize_number() {
                    Ok(number_kind) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        tokens.push(Token {
                            kind: TokenKind::Number(number_kind),
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        })
                    }
                    Err(kind) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        errors.push(TokenizationError {
                            kind,
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        });
                        state.synchronize();
                    }
                },
                Some("-") if state.peek(1) == Some("-") && state.peek(2) == Some("-") => match state.tokenize_documentation() {
                    Ok(content) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        tokens.push(Token {
                            kind: TokenKind::Doc(content),
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        })
                    }
                    Err(kind) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        errors.push(TokenizationError {
                            kind,
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        });
                        state.synchronize();
                    }
                },
                Some(punct) => match state.tokenize_punctuation(punct) {
                    Some(kind) => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        tokens.push(Token {
                            kind: TokenKind::Punctuation(kind),
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        })
                    }
                    None => {
                        let end_pos = Position {
                            line: state.line,
                            col: state.col,
                            byte_offset: state.byte_offset,
                        };
                        errors.push(TokenizationError {
                            kind: TokenizationErrorKind::UnknownToken,
                            span: Span {
                                start: start_pos,
                                end: end_pos,
                            },
                        });
                        state.synchronize();
                    }
                },
                None => break,
            };
        }

        (tokens, errors)
    }
}

fn is_letter(value: &str) -> bool {
    value.graphemes(true).count() == 1 && value.chars().all(char::is_alphabetic)
}

fn is_digit(value: &str) -> bool {
    value.graphemes(true).count() == 1 && value.chars().all(|x| char::is_ascii_digit(&x))
}

fn is_alphanumeric(value: &str) -> bool {
    value.graphemes(true).count() == 1 && value.chars().all(char::is_alphanumeric)
}

fn is_keyword(identifier: &str) -> Option<KeywordKind> {
    match identifier {
        "fn" => Some(KeywordKind::Fn),
        "let" => Some(KeywordKind::Let),
        "return" => Some(KeywordKind::Return),
        "if" => Some(KeywordKind::If),
        "else" => Some(KeywordKind::Else),
        "while" => Some(KeywordKind::While),
        "break" => Some(KeywordKind::Break),
        "continue" => Some(KeywordKind::Continue),
        "type" => Some(KeywordKind::Type),
        "from" => Some(KeywordKind::From),
        "void" => Some(KeywordKind::Void),
        "true" => Some(KeywordKind::True),
        "false" => Some(KeywordKind::False),
        "pub" => Some(KeywordKind::Pub),
        "bool" => Some(KeywordKind::Bool),
        "i8" => Some(KeywordKind::I8),
        "i16" => Some(KeywordKind::I16),
        "i32" => Some(KeywordKind::I32),
        "i64" => Some(KeywordKind::I64),
        "u8" => Some(KeywordKind::U8),
        "u16" => Some(KeywordKind::U16),
        "u32" => Some(KeywordKind::U32),
        "u64" => Some(KeywordKind::U64),
        "f32" => Some(KeywordKind::F32),
        "f64" => Some(KeywordKind::F64),
        "usize" => Some(KeywordKind::USize),
        "isize" => Some(KeywordKind::ISize),
        "match" => Some(KeywordKind::Match),
        "enum" => Some(KeywordKind::Enum),
        "struct" => Some(KeywordKind::Struct),
        "mut" => Some(KeywordKind::Mut),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        ast::{Position, Span},
        tokenize::{KeywordKind, NumberKind, PunctuationKind, Token, TokenKind, Tokenizer},
    };
    use pretty_assertions::assert_eq;

    #[test]
    fn test_skip_single_line_comment() {
        let input = "// This is a comment\nlet x = 10;";
        let (tokens, _) = Tokenizer::tokenize(input);

        assert_eq!(
            tokens,
            vec![
                Token {
                    kind: TokenKind::Keyword(KeywordKind::Let),
                    span: Span {
                        start: Position {
                            line: 2,
                            col: 1,
                            byte_offset: 21
                        },
                        end: Position {
                            line: 2,
                            col: 4,
                            byte_offset: 24
                        }
                    }
                },
                Token {
                    kind: TokenKind::Identifier("x"),
                    span: Span {
                        start: Position {
                            line: 2,
                            col: 5,
                            byte_offset: 25
                        },
                        end: Position {
                            line: 2,
                            col: 6,
                            byte_offset: 26
                        }
                    }
                },
                Token {
                    kind: TokenKind::Punctuation(PunctuationKind::Eq),
                    span: Span {
                        start: Position {
                            line: 2,
                            col: 7,
                            byte_offset: 27
                        },
                        end: Position {
                            line: 2,
                            col: 8,
                            byte_offset: 28
                        }
                    }
                },
                Token {
                    kind: TokenKind::Number(NumberKind::I64(10)),
                    span: Span {
                        start: Position {
                            line: 2,
                            col: 9,
                            byte_offset: 29
                        },
                        end: Position {
                            line: 2,
                            col: 11,
                            byte_offset: 31
                        }
                    }
                },
                Token {
                    kind: TokenKind::Punctuation(PunctuationKind::SemiCol),
                    span: Span {
                        start: Position {
                            line: 2,
                            col: 11,
                            byte_offset: 31
                        },
                        end: Position {
                            line: 2,
                            col: 12,
                            byte_offset: 32
                        }
                    }
                }
            ]
        );
    }

    #[test]
    fn test_skip_multiple_single_line_comments() {
        let input = "// Comment 1\n// Comment 2\nlet x = 10;";
        let (tokens, _) = Tokenizer::tokenize(input);

        assert_eq!(tokens.len(), 5);
        assert_eq!(tokens[0].kind, TokenKind::Keyword(KeywordKind::Let));
    }

    #[test]
    fn test_comment_at_end_of_input() {
        let input = "let x = 10; // Comment at the end";
        let (tokens, _) = Tokenizer::tokenize(input);

        assert_eq!(tokens.len(), 5);
        assert_eq!(tokens[0].kind, TokenKind::Keyword(KeywordKind::Let));
    }

    #[test]
    fn test_no_comments() {
        let input = "let x = 10;";
        let (tokens, _) = Tokenizer::tokenize(input);

        assert_eq!(tokens.len(), 5);
        assert_eq!(tokens[0].kind, TokenKind::Keyword(KeywordKind::Let));
    }

    #[test]
    fn test_only_comments() {
        let input = "// Only a comment";
        let (tokens, _) = Tokenizer::tokenize(input);
        assert_eq!(tokens.len(), 0);
    }
}

```

`WillowLang/src/tokenize/tokenize_documentation.rs`:

```rs
use super::{TokenizationErrorKind, Tokenizer};

impl<'a> Tokenizer<'a> {
    pub fn tokenize_documentation(&mut self) -> Result<&'a str, TokenizationErrorKind> {
        self.consume();
        self.consume();
        self.consume();

        let start = self.grapheme_offset;
        while let Some(c) = self.current() {
            if c == "-" && self.peek(1) == Some("-") && self.peek(2) == Some("-") {
                let doc_content = self.slice(start, self.grapheme_offset);
                self.consume();
                self.consume();
                self.consume();
                return Ok(doc_content);
            }
            self.consume();
        }

        Err(TokenizationErrorKind::UnterminatedDoc)
    }
}

```

`WillowLang/src/tokenize/tokenize_identifier.rs`:

```rs
use super::{is_alphanumeric, Tokenizer};

impl<'a> Tokenizer<'a> {
    pub fn tokenize_identifier(&mut self) -> &'a str {
        let start = self.grapheme_offset;
        while let Some(c) = self.current() {
            if is_alphanumeric(c) || c == "_" {
                self.consume();
            } else {
                break;
            }
        }

        self.slice(start, self.grapheme_offset)
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        ast::{Position, Span},
        tokenize::{Token, TokenKind, Tokenizer},
    };
    use pretty_assertions::assert_eq;

    #[test]
    fn tokenizes_simple_identifiers() {
        let (tokens, _) = Tokenizer::tokenize("hello");

        assert_eq!(
            tokens,
            vec![Token {
                kind: TokenKind::Identifier("hello"),
                span: Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0
                    },
                    end: Position {
                        line: 1,
                        col: 6,
                        byte_offset: 5
                    }
                }
            }]
        )
    }

    #[test]
    fn tokenizes_sequence_as_identifier() {
        let (tokens, _) = Tokenizer::tokenize("\nstructhello");

        assert_eq!(
            tokens,
            vec![Token {
                kind: TokenKind::Identifier("structhello"),
                span: Span {
                    start: Position {
                        line: 2,
                        col: 1,
                        byte_offset: 1
                    },
                    end: Position {
                        line: 2,
                        col: 12,
                        byte_offset: 12
                    }
                }
            }]
        )
    }
}

```

`WillowLang/src/tokenize/tokenize_number.rs`:

```rs
use super::{is_digit, is_letter, NumberKind, TokenizationErrorKind, Tokenizer};

impl<'a> Tokenizer<'a> {
    pub fn tokenize_number(&mut self) -> Result<NumberKind, TokenizationErrorKind> {
        let start = self.grapheme_offset;
        let mut has_dot = false;

        while let Some(c) = self.current() {
            if is_digit(c) {
                self.consume();
            } else if c == "." && !has_dot {
                has_dot = true;
                self.consume();
            } else if c == "." && has_dot {
                return Err(TokenizationErrorKind::InvalidFloatingNumber);
            } else if is_letter(c) {
                self.consume();
            } else {
                break;
            }
        }

        let number_str = self.slice(start, self.grapheme_offset);

        parse_number(number_str)
    }
}

const SUFFIX_INFOS: [(&str, bool); 12] = [
    ("f64", true),
    ("f32", true),
    ("usize", false),
    ("u64", false),
    ("u32", false),
    ("u16", false),
    ("u8", false),
    ("isize", false),
    ("i64", false),
    ("i32", false),
    ("i16", false),
    ("i8", false),
];

fn parse_number(full_number_str: &str) -> Result<NumberKind, TokenizationErrorKind> {
    for (suffix_str, is_float_suffix) in SUFFIX_INFOS {
        if full_number_str.ends_with(suffix_str) {
            let numeric_part = &full_number_str[..full_number_str.len() - suffix_str.len()];

            if !is_float_suffix && numeric_part.contains('.') {
                // e.g. "1.0u8"
                return Err(TokenizationErrorKind::InvalidIntegerNumber);
            }
            if is_float_suffix && numeric_part == "." {
                // e.g. ".f32"
                return Err(TokenizationErrorKind::InvalidFloatingNumber);
            }

            let result: Result<NumberKind, _> = match suffix_str {
                "f64" => numeric_part
                    .parse::<f64>()
                    .map(NumberKind::F64)
                    .or(Err(TokenizationErrorKind::InvalidFloatingNumber)),
                "f32" => numeric_part
                    .parse::<f32>()
                    .map(NumberKind::F32)
                    .or(Err(TokenizationErrorKind::InvalidFloatingNumber)),
                "usize" => numeric_part
                    .parse::<usize>()
                    .map(NumberKind::USize)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "u64" => numeric_part
                    .parse::<u64>()
                    .map(NumberKind::U64)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "u32" => numeric_part
                    .parse::<u32>()
                    .map(NumberKind::U32)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "u16" => numeric_part
                    .parse::<u16>()
                    .map(NumberKind::U16)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "u8" => numeric_part
                    .parse::<u8>()
                    .map(NumberKind::U8)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "isize" => numeric_part
                    .parse::<isize>()
                    .map(NumberKind::ISize)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "i64" => numeric_part
                    .parse::<i64>()
                    .map(NumberKind::I64)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "i32" => numeric_part
                    .parse::<i32>()
                    .map(NumberKind::I32)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "i16" => numeric_part
                    .parse::<i16>()
                    .map(NumberKind::I16)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                "i8" => numeric_part
                    .parse::<i8>()
                    .map(NumberKind::I8)
                    .or(Err(TokenizationErrorKind::InvalidIntegerNumber)),
                _ => unreachable!("Suffix matched in loop but not in match block"),
            };

            return result;
        }
    }

    if full_number_str.contains('.') {
        full_number_str
            .parse::<f64>()
            .map(NumberKind::F64)
            .or(Err(TokenizationErrorKind::InvalidFloatingNumber))
    } else {
        full_number_str
            .parse::<i64>()
            .map(NumberKind::I64)
            .or(Err(TokenizationErrorKind::InvalidIntegerNumber))
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        ast::{Position, Span},
        tokenize::{NumberKind, Token, TokenKind, Tokenizer},
    };
    use pretty_assertions::assert_eq;

    #[test]
    fn tokenizes_numbers_with_suffixes() {
        let test_cases = vec![
            (
                "1.",
                NumberKind::F64(1.0f64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 3,
                        byte_offset: 2,
                    },
                },
            ),
            (
                "1.5",
                NumberKind::F64(1.5f64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 4,
                        byte_offset: 3,
                    },
                },
            ),
            (
                "1",
                NumberKind::I64(1i64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 2,
                        byte_offset: 1,
                    },
                },
            ),
            (
                "1.5f64",
                NumberKind::F64(1.5f64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 7,
                        byte_offset: 6,
                    },
                },
            ),
            (
                "1.5f32",
                NumberKind::F32(1.5f32),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 7,
                        byte_offset: 6,
                    },
                },
            ),
            (
                "1f64",
                NumberKind::F64(1f64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1f32",
                NumberKind::F32(1f32),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1u8",
                NumberKind::U8(1u8),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 4,
                        byte_offset: 3,
                    },
                },
            ),
            (
                "1u16",
                NumberKind::U16(1u16),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1u32",
                NumberKind::U32(1u32),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1u64",
                NumberKind::U64(1u64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1i8",
                NumberKind::I8(1i8),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 4,
                        byte_offset: 3,
                    },
                },
            ),
            (
                "1i16",
                NumberKind::I16(1i16),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1i32",
                NumberKind::I32(1i32),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
            (
                "1i64",
                NumberKind::I64(1i64),
                Span {
                    start: Position {
                        line: 1,
                        col: 1,
                        byte_offset: 0,
                    },
                    end: Position {
                        line: 1,
                        col: 5,
                        byte_offset: 4,
                    },
                },
            ),
        ];

        for (input, expected_kind, span) in test_cases {
            let (tokens, errors) = Tokenizer::tokenize(input);

            if errors.len() > 0 {
                dbg!("re", input);
            }

            assert_eq!(errors, vec![]);

            assert_eq!(
                tokens,
                vec![Token {
                    span,
                    kind: TokenKind::Number(expected_kind),
                }]
            );
        }
    }
}

```

`WillowLang/src/tokenize/tokenize_punctuation.rs`:

```rs
use super::{PunctuationKind, Tokenizer};

impl<'a> Tokenizer<'a> {
    pub fn tokenize_punctuation(&mut self, punct: &str) -> Option<PunctuationKind> {
        match punct {
            ":" => match self.peek(1) {
                Some(":") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::DoubleCol)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::Col)
                }
            },
            "|" => match self.peek(1) {
                Some("|") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::DoubleOr)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::Or)
                }
            },
            "&" => match self.peek(1) {
                Some("&") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::DoubleAnd)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::And)
                }
            },
            "=" => match self.peek(1) {
                Some("=") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::DoubleEq)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::Eq)
                }
            },
            "<" => match self.peek(1) {
                Some("=") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::Lte)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::Lt)
                }
            },
            ">" => match self.peek(1) {
                Some("=") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::Gte)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::Gt)
                }
            },
            "!" => match self.peek(1) {
                Some("=") => {
                    self.consume();
                    self.consume();
                    Some(PunctuationKind::NotEq)
                }
                _ => {
                    self.consume();
                    Some(PunctuationKind::Not)
                }
            },
            ";" => {
                self.consume();
                Some(PunctuationKind::SemiCol)
            }
            "." => {
                self.consume();
                Some(PunctuationKind::Dot)
            }
            "(" => {
                self.consume();
                Some(PunctuationKind::LParen)
            }
            ")" => {
                self.consume();
                Some(PunctuationKind::RParen)
            }
            "[" => {
                self.consume();
                Some(PunctuationKind::LBracket)
            }
            "]" => {
                self.consume();
                Some(PunctuationKind::RBracket)
            }
            "{" => {
                self.consume();
                Some(PunctuationKind::LBrace)
            }
            "}" => {
                self.consume();
                Some(PunctuationKind::RBrace)
            }
            "+" => {
                self.consume();
                Some(PunctuationKind::Plus)
            }
            "-" => {
                self.consume();
                Some(PunctuationKind::Minus)
            }
            "*" => {
                self.consume();
                Some(PunctuationKind::Star)
            }
            "/" => {
                self.consume();
                Some(PunctuationKind::Slash)
            }
            "%" => {
                self.consume();
                Some(PunctuationKind::Percent)
            }
            "," => {
                self.consume();
                Some(PunctuationKind::Comma)
            }
            "$" => {
                self.consume();
                Some(PunctuationKind::Dollar)
            }
            "?" => {
                self.consume();
                Some(PunctuationKind::Question)
            }
            _ => None,
        }
    }
}

```

`WillowLang/src/tokenize/tokenize_string.rs`:

```rs
use super::{TokenizationErrorKind, Tokenizer};

impl<'a> Tokenizer<'a> {
    pub fn string(&mut self) -> Result<&'a str, TokenizationErrorKind> {
        self.consume();
        let literal_start = self.grapheme_offset;

        while let Some(c) = self.current() {
            match c {
                "\"" => {
                    let value = self.slice(literal_start, self.grapheme_offset);
                    self.consume();
                    return Ok(value);
                }
                "\\" => {
                    self.consume();
                    if let Some(next_char) = self.current() {
                        match next_char {
                            "\"" | "\\" | "$" | "{" | "}" | "n" | "r" | "t" => {
                                self.consume();
                            }
                            _ => {
                                return Err(TokenizationErrorKind::UnknownEscapeSequence);
                            }
                        }
                    } else {
                        return Err(TokenizationErrorKind::UnterminatedString);
                    }
                }
                _ => self.consume(),
            }
        }

        Err(TokenizationErrorKind::UnterminatedString)
    }
}

```